;*********************************************************/;* This source code copyright (c) 1991-2001, Aaron Giles */;* See the Read Me file for licensing information.       */;* Contact email: mac@aarongiles.com                     */;*********************************************************/	movem.l	d3-d6/a6,-(sp)				;Save our registers	move.l	28(sp),a6					;Get the address of the FillData structure in a6										;(based off stack: 5 registers + 1 a6 link + 1 return										;				   = 7 * 4 = 28 bytes)	move.l	#31744,d5					;AND mask for red part (31744 == $7c00)	move.l	#992,d4						;  for green part	(992 = $3e00)	move.l	#31,d3						;  for blue part	(31 == $001f)	movea.l	baseAdr(a6),a0				;Get the starting address in a0	movea.l	histogram(a6),a1			;Point a1 to our histogram@RLoop32:	move.l	a0,-(sp)					;Push the address on the stack	move.l	width(a6),d6				;Get the width counter	subq.l	#1,d6						;Minus one@CLoop32:	move.l	(a0)+,d0					;Get the colors in d0	move.l	d0,d1						;Copy this to d1	move.l	d0,d2						;And to d2	lsr.l	#3,d0						;Get the blue bits in place	and.l	d3,d0						;Kill off all except the blue	lsr.l	#6,d1						;Get the green bits in place	and.l	d4,d1						;Kill off the others	add.l	d1,d0						;Add in the green	moveq.l	#9,d1						;Get the shift count in d1	lsr.l	d1,d2						;Get the red bits in place	and.l	d5,d2						;Kill off the other bits	add.l	d2,d0						;Add that in as well	addq.w	#1,(0,a1,d0.l*2)			;Increment the histogram	beq.s	@RZero32					;Fix this if it's zero	dbra.w	d6,@CLoop32					;Continue the loop over all columns	bra.s	@Skip32						;Skip over the RZero part@RZero32:	subq.w	#1,(0,a1,d0.l*2)			;Put it back to 0xffff	dbra.w	d6,@CLoop32					;Loop over the remaining columns@Skip32:	movea.l	(sp)+,a0					;Return to the beginning of the row	adda.l	rowBytes(a6),a0				;Go to the next row	subq.l	#1,height(a6)				;Decrement the height	bne.s	@RLoop32					;If non-zero, branch	movem.l	(sp)+,d3-d6/a6				;Restore our registers