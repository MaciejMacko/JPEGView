;*********************************************************/;* This source code copyright (c) 1991-2001, Aaron Giles */;* See the Read Me file for licensing information.       */;* Contact email: mac@aarongiles.com                     */;*********************************************************/;;	On entry here we expect the following values:;;		a0 = pointer to the 24-bit source pixmap row;		a1 = pointer to the 8-bit destination pixmap row;		d2 = pointer to the region buffer;		d7 = (low word) column count;;	The following registers will be modified:;;		d0,d1,d2,d3,d4,d5,d6,d7;		a0,a1,a3;;	Internally, the register usage is as follows:;;		d0 = accumulator;		d1 = accumulator;		d6 = (low word) region column counter;		d7 = (low word) column counter;		;		a0 = pointer to 24-bit source row;		a1 = pointer to 8-bit destination row;		a2 = pointer to region buffer;	move.l	d2,a2				;and the real a2 from d2	subq.w	#1,d7				;subtract 1 from the width for dbra;;	Set up the region column counter in d6;	move.w	(a2)+,d6			;get region start in d6	bne.s	@CopyLoop			;if not zero, skip over this business	sub.w	(a2)+,d6			;otherwise, subtract the next word;;	Determine whether or not to draw this pixel, and handle switches;@CopyLoop:	tst.w	d6					;is d6 negative?	bmi.s	@CopyStore			;if so, store this value	addq.w	#4,a0				;skip past the current source pixel	addq.w	#4,a1				;skip past the current dest. pixel	subq.w	#1,d6				;decrement this counter	bne.s	@CopyCont			;if non-zero continue	sub.w	(a2)+,d6			;get the negative of the next value	add.w	-4(a2),d6			;and add the previous one	bra.s	@CopyCont			;continue@CopyStore:	move.l	(a0)+,(a1)+			;store the value to the output	addq.w	#1,d6				;increment the counter	bne.s	@CopyCont			;if non-zero, continue	move.w	(a2)+,d6			;get the next value	sub.w	-4(a2),d6			;minus the previous;;	End of loop: go until done;@CopyCont:	dbra.w	d7,@CopyLoop		;loop until done