;*********************************************************/;* This source code copyright (c) 1991-2001, Aaron Giles */;* See the Read Me file for licensing information.       */;* Contact email: mac@aarongiles.com                     */;*********************************************************/	machine mc68020	include 'Traps.a'	include 'SysEqu.a'; Note that all parameters are offset 24:;    4 bytes for return address from trap;   20 bytes for saved registers;; So:;   24(sp) = flags;   28(sp) = device handle;   32(sp) = color table handle;   36(sp) = rectangle;   40(sp) = depth;   42(sp) = pointer to destination gworld;   46(sp) = result codeuseTempMem equ 4memFullErr equ -108QDxDispatchPatch proc exportOnOffSwitch dc.w 0RoundGWorld dc.w 0OriginalTrap dc.l 0	tst.w	d0					;is this a NewGWorld call?	bne.s	@DontBother			;if not, skip all this fun	tst.w	OnOffSwitch(pc)		;are we on or off?	beq.s	@DontBother			;if off, skip all this	movem.l	d0-d2/a0/a1,-(sp)	;save registers on the stack	move.l	24(sp),d0			;get flags in d0	andi.b	#useTempMem,d0		;isolate the temp mem bit	beq.s	@PopAndDontBother	;if not on, skip entirely	movea.l	36(sp),a0			;get address of rectangle in a0	move.w	4(a0),d0			;get bottom	sub.w	(a0),d0				;minus top in d0	move.w	6(a0),d1			;get right	sub.w	2(a0),d1			;minus left in d1	mulu.w	d1,d0				;times each other	moveq.l	#0,d1				;clear out d1	move.w	40(sp),d1			;get depth in d1	bne.s	@NotZeroDepth		;if non-zero, skip ahead	moveq.l	#32,d1				;otherwise, assume worst-case (32)@NotZeroDepth:	cmpi.w	#32,d1				;above 32?	ble.s	@GoAhead			;if not, skip	subi.w	#32,d1				;subtract 32 (since it's grayscale)@GoAhead:	mulu.l	d1,d0				;get depth * height * width	lsr.l	#3,d0				;divide by 8	cmpi.l	#$00080000,d0		;less than 512k?	blt.s	@AdjustGWorldSize	;if so, let it happen, but round to 16 pixels	move.w	#memFullErr,46(sp)	;store an error	movea.l	42(sp),a0			;get address of gworldptr	clr.l	(a0)				;zero the result	movem.l	(a7)+,d0-d2/a0/a1	;restore our registers	movea.l	(a7)+,a1			;get return address in a1	adda.w	#$16,sp				;pop off parameters from stack	jmp		(a1)				;return to caller@AdjustGWorldSize:	tst.w	RoundGWorld(pc)		;should we round to nearest 16 pixels?	beq.s	@PopAndDontBother	;if not, skip	move.w	4(a0),d0			;get bottom of rect	addi.w	#15,d0				;add 15	andi.w	#$fff0,d0			;round to the nearest 16 pixels	move.w	d0,4(a0)			;store this as new bottom@PopAndDontBother:	movem.l	(a7)+,d0-d2/a0/a1	;restore our registers@DontBother:	move.l	OriginalTrap(pc),-(a7);push original address on stack	rts							;jump there;	andi.l	#$ffffffff-useTempMem,4(sp)	;clear the useTempMem bit;	lea		OldZone(pc),a0		;point a0 to our old zone storage;	move.l	TheZone,(a0)		;save the old zone in a0;	move.l	ApplZone,a0			;get the application zone in a0;	_SetZone					;and set it now;	move.l	d0,-(sp)			;save d0 on the stack;	move.l	#$00018000,d0		;get 96k in d0;	_PurgeMem					;purge enough memory to get that size;	_MaxBlock					;now get largest contig block;	cmpi.l	#$00018000,d0		;is it more than 96k?;	bge.s	@SetTo64k			;if so, clamp to 64k;	moveq.l	#0,a0				;otherwise, zero out the "handle";	ori.l	#useTempMem,8(sp)	;turn the temp mem flag back on;	bra.s	@DontAllocate		;and skip over the allocation;@SetTo64k:;	move.l	#$00010000,d0		;set value to 64k;	_NewHandle					;get a new handle of that size;@DontAllocate:;	move.l	a0,d0				;copy handle to d0;	lea		TempHandle(pc),a0	;get the address of the temp handle storage;	move.l	d0,(a0)				;store the new handle there;	move.l	(sp)+,d0			;restore d0 and a0;	lea		OrigReturn(pc),a0	;point a0 to our local storage;	move.l	(sp)+,(a0)			;and get original return address;	move.l	OriginalTrap(pc),a0	;get original trap address;	jsr		(a0)				;branch to the subroutine;	move.l	TempHandle(pc),a0	;get the temp handle back;	tst.l	a0					;is it nil?;	beq.s	@DontDispose		;if something went wrong, don't dispose;	_DisposHandle				;otherwise, get rid of the handle;@DontDispose:;	move.l	OldZone(pc),a0		;get old zone in a0;	_SetZone					;make sure we point back to it;	move.l	OrigReturn(pc),a0	;get original return address;	jmp		(a0)				;and jmp there;;@DontBother:;	move.l	OriginalTrap(pc),-(sp);store the return address on the stack;	rts							;and return there;TempHandle dc.l 0;OrigReturn dc.l 0;OldZone dc.l 0	endp	end