;*********************************************************/;* This source code copyright (c) 1991-2001, Aaron Giles */;* See the Read Me file for licensing information.       */;* Contact email: mac@aarongiles.com                     */;*********************************************************/;;	On entry here we expect the following values:;;		a0 = pointer to the 24-bit source pixmap row;		a1 = pointer to the 8-bit destination pixmap row;		a2 = pointer to the inverse color table;		a3 = pointer to the color table;		d0 = pointer to the even row dithering buffer;		d1 = pointer to the odd row dithering buffer;		d2 = pointer to the region buffer;		d6 = pointer to the range-limit table;		d7 = (low word) column count;;	The following registers will be modified:;;		d0,d1,d2,d3,d4,d5,d6,d7;		a0,a1,a3;;	Internally, the register usage is as follows:;;		d0 = accumulator;		d1 = accumulator;		d2 = current sum of red components (<< 4);		d3 = current sum of green components (<< 4);		d4 = current sum of blue components (<< 4);		d5 = (low word) ANDing mask = 0x0ff0;		d5 = (high word) temporary storage for red error;		d6 = (low word) region column counter;		d6 = (high word) temporary storage for green error;		d7 = (low word) column counter;		d7 = (high word) temporary storage for blue error;		;		a0 = pointer to 24-bit source row;		a1 = pointer to 8-bit destination row;		a2 = pointer to inverse color table;		a3 = pointer to color table;		a4 = pointer to even dithering buffer;		a5 = pointer to odd dithering buffer;		a6 = pointer to region buffer;	movem.l	a5/a6,-(sp)			;save a5/a6 on the stack	move.l	d0,a4				;get the real a4 from d0	move.l	d1,a5				;and the real a5 from d1	move.l	d2,a6				;and the real a6 from d2;;	Skip to the ends of everything here;	clr.l	d1					;clear d1	move.w	d7,d1				;copy the width to d1	adda.l	d1,a1				;add this to the destination ptr	move.l	d1,d0				;copy it to d0	lsl.l	#2,d0				;multiply by 4	adda.l	d0,a0				;and add to the source ptr	add.l	d1,d0				;add it again = times 5	add.l	d1,d0				;once more = times 6	adda.l	d0,a4				;now point to the end of the even row	adda.l	d0,a5				;and the end of the odd row;;	Initialize our counters and clear out next row;	move.w	d7,d0				;copy the width to d0	subq.w	#1,d7				;subtract 1 from the width for dbra	swap	d7					;swap this info high	move.w	d0,d7				;copy width back to lower word in d7	clr.w	d3					;clear the leftover dithering: red	clr.w	-2(a4)				;clear the even row dithering: blue	clr.w	d4					;green	clr.w	-4(a4)				;green	clr.w	d5					;blue	clr.w	-6(a4)				;red;;	Set up the region column counter in d6;@ERgnLoop:	cmp.w	(a6)+,d7			;have we found the end yet?	bgt.s	@ERgnLoop			;if not, loop	beq.s	@ERgnOn				;if equal, we're on at the end	subq.w	#2,a6				;back up one word	sub.w	-(a6),d7			;get region count in d6	bra.s	@OddStart			;if not zero, skip over this business@ERgnOn:	subq.w	#2,a6				;back up one word	move.w	-(a6),d7			;get previous value	sub.w	2(a6),d7			;subtract the next (larger) value@OddStart:	swap	d7					;swap this information high	exg.l	d6,a6				;swap region/table pointers;;	Begin main loop here;@OddLoop:	swap	d7					;save the column counter;;	Combine the accumulated errors and round to a pixel value;	add.w	-(a5),d5			;add dithering from previous row: blue	addq.w	#8,d5				;round if necessary	asr.w	#4,d5				;divide by 16 to get offset	move.w	0(a6,d5.w*2),d5		;range-limit the error	add.w	-(a5),d4			;add dithering from previous row: green	addq.w	#8,d4				;round if necessary	asr.w	#4,d4				;divide by 16 to get offset	move.w	0(a6,d4.w*2),d4		;range-limit the error	add.w	-(a5),d3			;add dithering from previous row: red	addq.w	#8,d3				;round if necessary	asr.w	#4,d3				;divide by 16 to get offset	move.w	0(a6,d3.w*2),d3		;range-limit the error;;	Offset the current pixel by the errors;@ErrDone:	move.l	-(a0),d1			;get source pixel in d1	move.w	d1,d0				;copy to d0	lsr.w	#8,d0				;shift to get the green	add.w	d0,d4				;add to green total	move.b	d1,d0				;get blue in d0	add.w	d0,d5				;add to blue total	swap	d1					;swap words	move.b	d1,d0				;get red in d0	add.w	d0,d3				;add to red total;;	Check for overflows and handle them;	bftst	d3{16:8}			;check bits 8-15 for red overflow	beq.s	@RedOK				;if okay, skip	spl.b	d3					;otherwise, set to ff/00	andi.w	#255,d3				;clear out the upper bits@RedOK:	bftst	d4{16:8}			;check bits 8-15 for green overflow	beq.s	@GreenOK			;if okay, skip	spl.b	d4					;otherwise, set to ff/00	andi.w	#255,d4				;clear out the upper bits@GreenOK:	bftst	d5{16:8}			;check bits 8-15 for blue overflow	beq.s	@BlueOK				;if okay, skip	spl.b	d5					;otherwise, set to ff/00	andi.w	#255,d5				;clear out the upper bits@BlueOK:;;	Get the inverse color table entry;	move.w	d5,d0				;get the blue bits in d0	ror.l	#8,d0				;rotate them off the right side	move.w	d4,d0				;get the green bits in d0	lsr.w	#3,d0				;shift off the low three bits	ror.l	#5,d0				;rotate them off the right side	move.w	d3,d0				;get the red bits in d0	lsr.w	#3,d0				;shift off the low three bits	ror.l	#6,d0				;rotate off the right side	swap	d0					;swap the result into the low word	clr.w	d1					;make sure the word in d1 is clear	move.b	0(a2,d0.w),d1		;get the inverse ctab entry in d1;;	Determine whether or not to draw this pixel, and handle switches;	tst.w	d7					;is d7 negative?	bmi.s	@OddStore			;if so, store this value	subq.w	#1,a1				;skip past the current pixel	subq.w	#1,d7				;decrement this counter	bne.s	@OddCont			;if non-zero continue	exg.l	a6,d6				;swap region/table pointers	move.w	-(a6),d7			;get the next value	sub.w	2(a6),d7			;and subtract the next one	exg.l	a6,d6				;swap back	bra.s	@OddCont			;continue@OddStore:	move.b	d1,-(a1)			;store the value to the output	addq.w	#1,d7				;increment the counter	bne.s	@OddCont			;if non-zero, continue	exg.l	a6,d6				;swap region/table pointers	sub.w	-(a6),d7			;subtract the next value	add.w	2(a6),d7			;and add the next	exg.l	a6,d6				;swap back;;	Get the real color for this entry;@OddCont:	move.l	4(a3,d1.w*8),d0		;get the green & blue components in d0	lsr.w	#8,d0				;shift 'em down	sub.w	d0,d5				;subtract from the desired blue	swap	d0					;get the green	lsr.w	#8,d0				;shift 'em down	sub.w	d0,d4				;subtract from the desired green	move.w	2(a3,d1.w*8),d0		;get the red comonent	lsr.w	#8,d0				;shift down by 4	sub.w	d0,d3				;subtract from the desired red;;	Divide the real color by 16 and set up to calculate odd multiples;	move.w	d3,d0				;copy error to d0-d2: red	move.w	d4,d1				;green	move.w	d5,d2				;blue	add.w	d0,d0				;double it in d0-d2: red	add.w	d1,d1				;green	add.w	d2,d2				;blue;;	Store 1/16, 3/16, and 5/16 into next row; leave 7/16 for neighbor;	movem.w	d3-d5,-12(a4)		;store 1/16 at (-1,+1): red/green/blue	add.w	d0,d3				;add 2 * error = 3/16: red	add.w	d1,d4				;green	add.w	d2,d5				;blue	add.w	d3, 0(a4)			;add 3/16 to (+1,+1): red	add.w	d0,d3				;add 2 * error = 5/16: red	add.w	d4, 2(a4)			;green	add.w	d1,d4				;green	add.w	d5, 4(a4)			;blue	add.w	d2,d5				;blue	add.w	d5,-(a4)			;add 5/16 to (0,+1): blue	add.w	d2,d5				;add 2 * error = 7/16: blue	add.w	d4,-(a4)			;green	add.w	d1,d4				;green	add.w	d3,-(a4)			;red	add.w	d0,d3				;red;;	End of loop: go until done;	swap	d7					;restore column counter	dbra.w	d7,@OddLoop			;loop until done	movem.l	(sp)+,a5/a6			;restore a5 from the stack