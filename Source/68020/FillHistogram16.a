;*********************************************************/;* This source code copyright (c) 1991-2001, Aaron Giles */;* See the Read Me file for licensing information.       */;* Contact email: mac@aarongiles.com                     */;*********************************************************/	movem.l	d3/d4/a6,-(sp)				;Save our registers	move.l	20(sp),a6					;Get the address of the FillData structure in a6										;(based off stack: 3 registers + 1 a6 link + 1 return										;				   = 5 * 4 = 20 bytes)	move.l	#32767,d3					;AND mask for this pixel	(32767 = $7fff)	movea.l	baseAdr(a6),a0				;Get the starting address in a0	movea.l	histogram(a6),a1			;Point a1 to our histogram@RLoop16:	move.l	a0,-(sp)					;Push the address on the stack	move.l	width(a6),d4				;Get the width counter	subq.l	#1,d4						;Minus one@CLoop16:	move.w	(a0)+,d0					;Get the colors in d0	and.l	d3,d0						;Clear out the alpha bit	addq.w	#1,(0,a1,d0.l*2)			;Increment the histogram	beq.s	@RZero16					;Fix this if it's zero	dbra.w	d4,@CLoop16					;Continue the loop over all columns	bra.s	@Skip16						;Skip over the RZero part@RZero16:	subq.w	#1,(0,a1,d0.l*2)			;Put it back to 0xffff	dbra.w	d4,@CLoop16					;Loop over the remaining columns@Skip16:	movea.l	(sp)+,a0					;Return to the beginning of the row	adda.l	rowBytes(a6),a0				;Go to the next row	subq.l	#1,height(a6)				;Decrement the height	bne.s	@RLoop16					;If non-zero, branch	movem.l	(sp)+,d3/d4/a6				;Restore our registers