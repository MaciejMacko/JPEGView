;*********************************************************/;* This source code copyright (c) 1991-2001, Aaron Giles */;* See the Read Me file for licensing information.       */;* Contact email: mac@aarongiles.com                     */;*********************************************************/;;	On entry here we expect the following values:;;		srcBase = (long) pointer to the first source pixel;		srcRow  = (long) rowBytes for the source pixmap;		dstBase = (long) pointer to the first destination pixel;		dstRow  = (long) rowBytes for the destination pixmap;		itAddr  = (long) pointer to the inverse color table;		ctAddr  = (long) pointer to the color table;		theRgn  = (long) handle to the destination region;		boxRect = (Rect) the bounding rectangle of this region;		height  = (word) height of the region bounding box;		width   = (word) width of the region bounding box;		even	= (long) pointer to the even row dithering routine;		odd		= (long) pointer to the odd row dithering routine;		evodd	= (short) word holding even/odd row information;		;	The following registers will be modified:;;		d0,d1,d2;		a0,a1;;	Internally, the register usage is as follows:;;		d0 = accumulator;		d1 = accumulator;		d6 = row counter;;		a0 = pointer to 24-bit source row;		a1 = pointer to 8-bit destination row;		a2 = pointer to inverse color table;		a3 = pointer to color table;	movem.l	d3-d7/a2-a6,-(sp)	;save the registers	move.l	48(sp),a6			;get the address of the CopyData structure in a6								;(based off stack: 10 registers + 1 a6 link + 1 return addr.								;					= 12 * 4 bytes = 48 bytes);;	Allocate space on the stack for our buffers;	clr.l	d0					;zero out d0	move.w	width(a6),d0		;get row width in d0	addq.l	#2,d0				;plus two for overflow	lsl.l	#2,d0				;width * 4	move.l	d0,d1				;copy to d1	lsl.l	#1,d0				;width * 8	add.l	d1,d0				;width * 12	sub.l	d0,sp				;make that much room on the stack	move.l	d0,-(sp)			;push the length	move.l	d0,d1				;copy to d1	moveq.l	#10,d0				;offset by 10 bytes = 6 bytes + 4 for length	add.l	sp,d0				;add in current stack pointer	move.l	d0,evenAddr(a6)		;save as evenAddr	lsr.l	#1,d1				;divide length by two	add.l	d1,d0				;add to this pointer	move.l	d0,oddAddr(a6)		;save as oddAddr;;	Clear out the dithering buffers;	subq.l	#4,d1				;decrement d1 for the dbra, plus the extras	move.l	evenAddr(a6),a0		;point a0 to the even address@ClearLoop:	clr.w	(a0)+				;clear the word at a0	dbra.w	d1,@ClearLoop		;loop until done;;	Initialize the region data;	move.l	theRgn(a6),a0		;get theRgn in a0	lea.l	rgnBuffer(a6),a1	;point a1 to the region buffer	move.w	boxRect+0(a6),d2	;get box top in d2	move.w	boxRect+2(a6),d3	;box left in d3	move.w	height(a6),d4		;height in d4	move.w	width(a6),d5		;width in d5	jsr		InitRegion			;initialize the region	move.l	a0,-(sp)			;store our pointer to the rgn on the stack;;	Set up our pointers and the row counter;	move.l	srcBase(a6),a0		;get the base for the source	move.l	dstBase(a6),a1		;get the base for the destination	move.l	itAddr(a6),a2		;point a2 to the inverse color table	move.l	ctAddr(a6),a3		;point a3 to the color table	move.w	height(a6),d6		;get the height of the destination in d6	subq.w	#1,d6				;minus one = row counter;;	Beginning of outer (row) loop: determine even/odd and dither;@RowLoop:	move.l	a0,-(sp)			;save source row pointer	move.l	a1,-(sp)			;save dest row pointer	move.w	width(a6),d7		;get the width in d7	lea.l	rgnBuffer+4(a6),a4	;get rgnBuffer address in a4	move.l	a4,d2				;point d2 (a6) to the region buffer	move.l	evenAddr(a6),d0		;point d0 (a4) to the even buffer	move.l	oddAddr(a6),d1		;point d1 (a5) to the odd buffer	move.l	d6,-(sp)			;save d6 on the stack	move.l	errTable(a6),d6		;point d6 to the error table	bchg.b	#0,evodd+1(a6)		;check the even/odd flag	beq.s	@RLEven				;if zero, dither evenly	move.l	odd(a6),a4			;get jump address	jsr		(a4)				;otherwise, dither oddly	bra.s	@RLEnd				;skip ahead@RLEven:	move.l	even(a6),a4			;get subroutine address here	jsr		(a4)				;dither the even row;;	Restore our state and increment by one row;@RLEnd:	move.l	(sp)+,d6			;get d6 from the stack	tst.w	d6					;are we done?	beq.s	@DitherDone1		;if we are, don't crash :-);;	Decrement the region Y counter and merge in the next scan line;	subq.w	#1,rgnBuffer(a6)	;decrement the Y count	bne.s	@RgnOk				;skip if we're not done	move.l	8(sp),a0			;get region pointer	lea.l	rgnBuffer+4(a6),a1	;point a1 into the region buffer	move.w	boxRect+2(a6),d0	;get left end of the box in d0	jsr		UpdateRegion		;update our region	move.l	a0,8(sp)			;save new position again;;	End of row loop: adjust pointers and loop until done;@RgnOk:	move.l	(sp)+,a1			;restore the destination ptr	add.l	dstRow(a6),a1		;increment by one row	move.l	(sp)+,a0			;restore the source ptr	add.l	srcRow(a6),a0		;increment by one row	dbra.w	d6,@RowLoop			;loop for more rows	addq.l	#4,sp				;pop off region position	bra.s	@DitherDone			;skip ahead@DitherDone1:	add.l	#12,sp				;pop off region, a0, a1 positions@DitherDone:	move.l	(sp)+,d0			;get the amount of extra space	add.l	d0,sp				;remove it from the stack	movem.l	(sp)+,d3-d7/a2-a6	;restore the registers