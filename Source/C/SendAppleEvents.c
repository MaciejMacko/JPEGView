/*********************************************************//* This source code copyright (c) 1991-2001, Aaron Giles *//* See the Read Me file for licensing information.       *//* Contact email: mac@aarongiles.com                     *//*********************************************************///=====================================================================================// Generic includes for Macintosh headers//=====================================================================================#if THINK_C#include "THINK.Header"#elif applec#pragma load ":Headers:MPW.Header"#elif __MWERKS__//#include "MW.Header"#else#include "JPEGView.h"#endif//=====================================================================================// Includes specific to this module//=====================================================================================#include "EventHandlers.h"//=====================================================================================// OSErr SendSetWindowBounds(WindowPtr theWindow, Rect *theRect)//// Sends a set data event to set the given window's global bounds.//// External calls: MakeWinPropertyObject, AEAddQDRectangle, HandleAEError//=====================================================================================extern OSErr SendSetWindowBounds(WindowPtr theWindow, Rect *theRect){	AppleEvent theEvent;	AEDesc theObject;	OSErr theErr;		if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kAECoreSuite, kAESetData);		if (theErr == noErr) {			theErr = MakeWinPropertyObject(theWindow, pBounds, &theObject);			if (theErr == noErr) {				theErr = AEPutParamDesc(&theEvent, keyDirectObject, &theObject);				AEDisposeDesc(&theObject);				if (theErr == noErr) AEAddQDRectangle(&theEvent, keyAEData, theRect);				if (theErr == noErr)					theErr = AESend(&theEvent, nil, kAENoReply + kAECanInteract, 							 kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);			}			AEDisposeDesc(&theEvent);		}	} else theErr = DoSetWindowBounds(theWindow, theRect);	HandleAEError(theErr, 0, nil);	return theErr;}//=====================================================================================// OSErr SendSetZoomed(WindowPtr theWindow, Boolean zoomed)//// Sends a set data event to set the given window's zoomed flag.//// External calls: MakeWinPropertyObject, AEAddBoolean, HandleAEError//=====================================================================================extern OSErr SendSetZoomed(WindowPtr theWindow, Boolean zoomed){	AppleEvent theEvent;	AEDesc theObject;	OSErr theErr;	if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kAECoreSuite, kAESetData);		if (theErr == noErr) {			theErr = MakeWinPropertyObject(theWindow, pIsZoomed, &theObject);			if (theErr == noErr) {				theErr = AEPutParamDesc(&theEvent, keyDirectObject, &theObject);				AEDisposeDesc(&theObject);				if (theErr == noErr) AEAddBoolean(&theEvent, keyAEData, &zoomed);				if (theErr == noErr)					theErr = AESend(&theEvent, nil, kAENoReply + kAECanInteract, 							 kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);			}			AEDisposeDesc(&theEvent);		}	} else theErr = DoZoomWindow(theWindow, zoomed);	HandleAEError(theErr, 0, nil);	return theErr;}/* * SendNewPalette(theImage, thePalette) * *     Purpose: Sends ourself an AppleEvent to set an image's palette *      Inputs: theImage = the image we're interested in *				thePalette = constant describing the palette *     Returns: nothing * */ OSErr SendNewPalette(ImageHandle theImage, DescType thePalette){	AppleEvent theEvent;	AEDesc theObject;	OSErr theErr;		if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kAECoreSuite, kAESetData);		if (theErr == noErr) {			theErr = MakeDrawPropertyObject((*theImage)->window, pPalette, &theObject);			if (theErr == noErr) {				theErr = AEPutParamDesc(&theEvent, keyDirectObject, &theObject);				AEDisposeDesc(&theObject);				if (theErr == noErr) theErr = AEAddEnumerated(&theEvent, keyAEData, &thePalette);				if (theErr == noErr)					theErr = AESend(&theEvent, nil, kAENoReply + kAECanInteract, 							 kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);			}			AEDisposeDesc(&theEvent);		}	} else theErr = DoSetPalette((*theImage)->window, thePalette);	HandleAEError(theErr, 0, nil);	return theErr;}/* * SendDither(theImage) * *     Purpose: Toggles the dither state of the current image *      Inputs: theImage = the image we're interested in *     Returns: nothing * */ OSErr SendDither(ImageHandle theImage, Boolean dither){	DescType theMode = dither ? kAEQDDitherCopy : kAEQDCopy;	AppleEvent theEvent;	AEDesc theObject;	OSErr theErr;		if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kAECoreSuite, kAESetData);		if (theErr == noErr) {			theErr = MakeDrawPropertyObject((*theImage)->window, pTransferMode, &theObject);			if (theErr == noErr) {				theErr = AEPutParamDesc(&theEvent, keyDirectObject, &theObject);				AEDisposeDesc(&theObject);				if (theErr == noErr) AEAddEnumerated(&theEvent, keyAEData, &theMode);				if (theErr == noErr)					theErr = AESend(&theEvent, nil, kAENoReply + kAECanInteract, 							 kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);			}			AEDisposeDesc(&theEvent);		}	} else theErr = DoSetImageDither(theImage, dither);	HandleAEError(theErr, 0, nil);	return theErr;}/* * SendQuality(theImage, theQuality) * *     Purpose: Sets the quality of the current image *      Inputs: theImage = the image we're interested in *     Returns: nothing * */ OSErr SendQuality(ImageHandle theImage, DescType theQuality){	AppleEvent theEvent;	AEDesc theObject;	OSErr theErr;		if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kAECoreSuite, kAESetData);		if (theErr == noErr) {			theErr = MakeDrawPropertyObject((*theImage)->window, pDrawQuality, &theObject);			if (theErr == noErr) {				theErr = AEPutParamDesc(&theEvent, keyDirectObject, &theObject);				AEDisposeDesc(&theObject);				if (theErr == noErr) AEAddEnumerated(&theEvent, keyAEData, &theQuality);				if (theErr == noErr)					theErr = AESend(&theEvent, nil, kAENoReply + kAECanInteract, 							 kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);			}			AEDisposeDesc(&theEvent);		}	} else theErr = DoSetImageQuality(theImage, theQuality);	HandleAEError(theErr, 0, nil);	return theErr;}/* * SendSetSelection(theImage, theRect) * *     Purpose: Sends a set data event to the selection to set the selection for an image *      Inputs: theImage = handle to the image of interest *				theRect = pointer to the new selection rect *     Returns: nothing * */ OSErr SendSetSelection(ImageHandle theImage, Rect *theRect){	AppleEvent theEvent;	AEDesc theObject;	OSErr theErr;		if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kAECoreSuite, kAESetData);		if (theErr == noErr) {			theErr = MakeSelPropertyObject((*theImage)->window, pBounds, &theObject);			if (theErr == noErr) {				theErr = AEPutParamDesc(&theEvent, keyDirectObject, &theObject);				AEDisposeDesc(&theObject);				if (theErr == noErr) AEAddQDRectangle(&theEvent, keyAEData, theRect);				if (theErr == noErr)					theErr = AESend(&theEvent, nil, kAENoReply + kAECanInteract, 							 kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);			}			AEDisposeDesc(&theEvent);		}	} else theErr = DoSetSelection(theImage, theRect);	HandleAEError(theErr, 0, nil);	return theErr;}/* * SendCloneDocument(theImage, theNewImage) * *     Purpose: Sends ourself an AppleEvent to clone a document and put the clone in *					front of all other documents *      Inputs: theImage = the image we're interested in *				theNewImage = pointer to a location to store the new image's ImageHandle *     Returns: nothing * */ OSErr SendCloneDocument(ImageHandle theImage, ImageHandle *theNewImage){	AEDesc theObject, theInsertionLoc, theReply, newObject;	Boolean theBoolean = false;	ObjectTokenHandle theToken;	AppleEvent theEvent;	OSErr theErr;		*theNewImage = nil;	if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kAECoreSuite, kAEClone);		if (theErr == noErr) {			theErr = MakeWindowObject((*theImage)->window, &theObject);			if (theErr == noErr) {				theErr = AEPutParamDesc(&theEvent, keyDirectObject, &theObject);				AEDisposeDesc(&theObject);				if (theErr == noErr) theErr = AEAddBoolean(&theEvent, keyVisible, &theBoolean);				if (theErr == noErr) theErr = AEMakeBeginningILoc(&theInsertionLoc, false);				if (theErr == noErr) {					theErr = AEPutParamDesc(&theEvent, keyAEInsertHere, &theInsertionLoc);					AEDisposeDesc(&theInsertionLoc);					if (theErr == noErr) {						theErr = AESend(&theEvent, &theReply, kAEWaitReply + kAECanInteract, 								 kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);						if (theErr == noErr) {							theErr = AEExtractObject(&theReply, keyAEResult, &newObject);							if (theErr == noErr) {								theToken = (ObjectTokenHandle)newObject.dataHandle;								*theNewImage = FindImage((WindowPtr)(*theToken)->object[0]);							}							AEDisposeDesc(&theReply);						}					}				}			}			AEDisposeDesc(&theEvent);		}	} else {		WindowPtr newWindow;		theErr = DoCloneWindow((*theImage)->window, nil, &newWindow);		*theNewImage = FindImage(newWindow);	}	HandleAEError(theErr, 0, nil);	return theErr;}/* * SendSetImageBounds(theImage, theRect) * *     Purpose: Sets the bounds property of the given window's image *      Inputs: theWindow = the window we're interested in *				theRect = the new bounds *     Returns: nothing * */ OSErr SendSetImageBounds(WindowPtr theWindow, Rect *theRect){	AppleEvent theEvent;	AEDesc theObject;	OSErr theErr;		if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kAECoreSuite, kAESetData);		if (theErr == noErr) {			theErr = MakeImagePropertyObject(theWindow, pBounds, &theObject);			if (theErr == noErr) {				theErr = AEPutParamDesc(&theEvent, keyDirectObject, &theObject);				AEDisposeDesc(&theObject);				if (theErr == noErr) AEAddQDRectangle(&theEvent, keyAEData, theRect);				if (theErr == noErr)					theErr = AESend(&theEvent, nil, kAENoReply + kAECanInteract, 							 kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);			}			AEDisposeDesc(&theEvent);		}	} else theErr = DoSetImageBounds(FindImage(theWindow), theRect);	HandleAEError(theErr, 0, nil);	return theErr;}/* * SendSetWindowVis(theWindow, visible) * *     Purpose: Sets the pIsVisible property of the given window *      Inputs: theWindow = the window we're interested in *				visible = flag: true to make the window visible *     Returns: nothing * */ OSErr SendSetWindowVis(WindowPtr theWindow, Boolean visible){	AppleEvent theEvent;	AEDesc theObject;	OSErr theErr;		if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kAECoreSuite, kAESetData);		if (theErr == noErr) {			theErr = MakeWinPropertyObject(theWindow, pVisible, &theObject);			if (theErr == noErr) {				theErr = AEPutParamDesc(&theEvent, keyDirectObject, &theObject);				AEDisposeDesc(&theObject);				if (theErr == noErr) AEAddBoolean(&theEvent, keyAEData, &visible);				if (theErr == noErr)					theErr = AESend(&theEvent, nil, kAENoReply + kAECanInteract, 							 kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);			}			AEDisposeDesc(&theEvent);		}	} else theErr = DoSetWindowVisible(theWindow, visible);	HandleAEError(theErr, 0, nil);	return theErr;}/* * SendOpenDocument(theSpec) * *     Purpose: Sends the open document AppleEvent to ourself *      Inputs: theSpec = pointer to the FSSpec record for the file *     Returns: nothing * */ OSErr SendOpenDocument(FSSpec *theSpec) {	AppleEvent theEvent;	OSErr theErr;	theErr = AENewEvent(&theEvent, kCoreEventClass, kAEOpenDocuments);	if (theErr == noErr) {		theErr = AEAddAliasList(&theEvent, keyDirectObject, theSpec, 1);		if (theErr == noErr)			theErr = AESend(&theEvent, nil, kAENoReply + kAECanInteract, 							kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);		AEDisposeDesc(&theEvent);	}	return theErr;}/* * SendCreateWindow(windowID) * *     Purpose: Sends the create AppleEvent to ourself with a cWindow object *      Inputs: windowID = ID value for the window to open *     Returns: nothing * */ OSErr SendCreateWindow(DescType windowID){	AEDesc theInsertionLoc, theRecord;	DescType theClass = cWindow;	AppleEvent theEvent;	OSErr theErr;	if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kAECoreSuite, kAECreateElement);		if (theErr == noErr) {			theErr = AEAddType(&theEvent, keyAEObjectClass, &theClass);			if (theErr == noErr) theErr = AEMakeBeginningILoc(&theInsertionLoc, true);			if (theErr == noErr) {				theErr = AEPutParamDesc(&theEvent, keyAEInsertHere, &theInsertionLoc);				AEDisposeDesc(&theInsertionLoc);				if (theErr == noErr) theErr = AECreateList(nil, 0, true, &theRecord);				if (theErr == noErr) {					theErr = AEPutKeyPtr(&theRecord, pWindowType, typeEnumerated, (void *)&windowID,							 sizeof(DescType));					if (theErr == noErr) AEPutParamDesc(&theEvent, keyAEPropData, &theRecord);					AEDisposeDesc(&theRecord);					if (theErr == noErr) {						if ((windowID == kPrefsDialogID) || (windowID == kSlideShowDialogID))							theErr = AESend(&theEvent, nil, 									 kAENoReply + kAECanInteract,// + kAEDontRecord, 									 kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);						else							theErr = AESend(&theEvent, nil, kAENoReply + kAECanInteract, 									 kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);					}				}			}			AEDisposeDesc(&theEvent);		}	} else {		WindowPtr dummyWindow;		theErr = DoCreateWindow(windowID, nil, &dummyWindow);	}	HandleAEError(theErr, 0, nil);	return theErr;}/* * SendCloseWindow(theWindow) * *     Purpose: Sends the close AppleEvent to ourself with a cWindow object *      Inputs: theWindow = pointer to the window, or kAEAll to close all windows *     Returns: nothing * */ OSErr SendCloseWindow(WindowPtr theWindow){	AppleEvent theEvent;	AEDesc theObject;	OSErr theErr;	if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kAECoreSuite, kAEClose);		if (theErr == noErr) {			if (theWindow == (WindowPtr)kAEAll)				theErr = MakeDocumentObject(theWindow, &theObject);			else theErr = MakeWindowObject(theWindow, &theObject);			if (theErr == noErr) {				theErr = AEPutParamDesc(&theEvent, keyDirectObject, &theObject);				AEDisposeDesc(&theObject);				if (theErr == noErr)					theErr = AESend(&theEvent, nil, kAENoReply + kAECanInteract, 									kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);			}			AEDisposeDesc(&theEvent);		}	} else {		ImageHandle theImage, prevImage;		if (theWindow == (WindowPtr)kAEAll)			for (theImage = LastImage(); theImage; theImage = prevImage) {				prevImage = PreviousImage(theImage);				theErr = DoCloseWindow((*theImage)->window, gThePrefs.restoreColors);			}		else theErr = DoCloseWindow(theWindow, gThePrefs.restoreColors);	}	HandleAEError(theErr, 0, nil);	return theErr;}/* * SendSaveDocument(theSpec, theFormat, preview, palette) * *     Purpose: Sends the save AppleEvent to ourself with a cDocument object *      Inputs: theSpec = pointer to the FSSpec record for the file *				theFormat = the destination file format *				preview = flag: true if we create and save a preview *				palette = flag: true if we save the quantized palette *     Returns: nothing * */ OSErr SendSaveDocument(FSSpec *theSpec, OSType theFormat, Boolean preview, Boolean palette,	Boolean icons, short cropWhat) {	OSErr theErr = noErr, intErr;	AppleEvent theEvent;	AEDesc theObject;	if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kAECoreSuite, kAESave);		if (theErr == noErr) {			theErr = MakeDocumentObject((*FrontImage())->window, &theObject);			if (theErr == noErr) {				theErr = AEPutParamDesc(&theEvent, keyDirectObject, &theObject);				AEDisposeDesc(&theObject);				if (theErr == noErr) theErr = AEAddAlias(&theEvent, keyAEFile, theSpec);				if (theErr == noErr) theErr = AEAddType(&theEvent, keyAEFileType, &theFormat);				if (theErr == noErr) theErr = AEAddBoolean(&theEvent, keyCreatePreview, &preview);				if (theErr == noErr) theErr = AEAddBoolean(&theEvent, keySaveQuant, &palette);				if (theErr == noErr) theErr = AEAddBoolean(&theEvent, keyMakeIcons, &icons);				if (theErr == noErr) theErr = AEAddShort(&theEvent, keyCropWhat, &cropWhat);				if (theErr == noErr)					theErr = AESend(&theEvent, nil, kAENoReply + kAECanInteract, 									kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);			}			AEDisposeDesc(&theEvent);		}		intErr = (OSErr)gIntError;		HandleAEError(theErr, errNoSaveMemory, theSpec->name);	} else theErr = DoSaveDocument(FrontImage(), theSpec, theFormat, preview, palette, icons, cropWhat);	return theErr;}/* * SendSlideShow() * *     Purpose: Sends the slide show AppleEvent to ourself *      Inputs: none *     Returns: nothing * */OSErr SendSlideShow(void) {	Boolean askUser = true;	AliasHandle theAlias;	AppleEvent theEvent;	AEDesc theDesc;	OSErr theErr;	if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kJPEGViewSuite, kAESlideShow);		if (theErr == noErr) {			theErr = LoadPrefsHandle(kPrefsAliasType, 0, (Handle *)&theAlias);			if (theErr == noErr) {				theErr = AECreateHandleDesc(typeAlias, (Handle)theAlias, &theDesc);				DisposeHandle((Handle)theAlias);				if (theErr == noErr) {					theErr = AEPutParamDesc(&theEvent, keyDirectObject, &theDesc);					AEDisposeDesc(&theDesc);					if (theErr == noErr)						theErr = AESend(&theEvent, nil, kAENoReply + kAECanInteract, 									kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);				}			}			AEDisposeDesc(&theEvent);		}	} else theErr = DoSlideShow();	HandleAEError(theErr, 0, nil);	return theErr;}/* * SendPrintDocument(theImage) * *     Purpose: Sends the print document AppleEvent to ourself *      Inputs:  *     Returns: nothing * */ OSErr SendPrintDocument(ImageHandle theImage) {	AppleEvent theEvent;	AEDesc theObject;	Str63 theName;	OSErr theErr;		if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kCoreEventClass, kAEPrintDocuments);		if (theErr == noErr) {			theErr = MakeDocumentObject((*theImage)->window, &theObject);			if (theErr == noErr) {				theErr = AEPutParamDesc(&theEvent, keyDirectObject, &theObject);				AEDisposeDesc(&theObject);				if (theErr == noErr)					theErr = AESend(&theEvent, nil, kAENoReply + kAECanInteract, 									kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);			}			AEDisposeDesc(&theEvent);		}		BlockMove((*theImage)->file.name, theName, *(*theImage)->file.name + 1);	} else theErr = DoPrintDocument(theImage, true);	HandleAEError(theErr, errNoPrintMemory, theName);	return theErr;}/* * SendQuitApplication() * *     Purpose: Sends the quit application AppleEvent to ourself *      Inputs: none *     Returns: nothing * */ OSErr SendQuitApplication(void) {	AppleEvent theEvent, theReply;	OSErr theErr;		theErr = AENewEvent(&theEvent, kCoreEventClass, kAEQuitApplication);	if (theErr == noErr) {		theErr = AESend(&theEvent, &theReply, kAENoReply + kAECanInteract, 				 kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);		AEDisposeDesc(&theEvent);	}	HandleAEError(theErr, 0, nil);	return theErr;}/* * SendSetFullScreen(theWindow, visible) * *     Purpose: Sets the pFullScreen property of the given window *      Inputs: theWindow = the window we're interested in *				full = flag: true to make the window full screen *     Returns: nothing * */ OSErr SendSetFullScreen(WindowPtr theWindow, Boolean full){	AppleEvent theEvent;	AEDesc theObject;	OSErr theErr;		if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kAECoreSuite, kAESetData);		if (theErr == noErr) {			theErr = MakeWinPropertyObject(theWindow, pFullScreen, &theObject);			if (theErr == noErr) {				theErr = AEPutParamDesc(&theEvent, keyDirectObject, &theObject);				AEDisposeDesc(&theObject);				if (theErr == noErr) AEAddBoolean(&theEvent, keyAEData, &full);				if (theErr == noErr)					theErr = AESend(&theEvent, nil, kAENoReply + kAECanInteract, 							 kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);			}			AEDisposeDesc(&theEvent);		}	} else theErr = DoSetWindowFull(theWindow, full);	HandleAEError(theErr, 0, nil);	return theErr;}/* * SendSetDrawBounds(theImage, theRect) * *     Purpose: Sets the bounds property of the given window's drawing area *      Inputs: theWindow = the window we're interested in *				theRect = the new bounds *     Returns: nothing * */ OSErr SendSetDrawBounds(WindowPtr theWindow, Rect *theRect){	AppleEvent theEvent;	AEDesc theObject;	OSErr theErr;		if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kAECoreSuite, kAESetData);		if (theErr == noErr) {			theErr = MakeDrawPropertyObject(theWindow, pBounds, &theObject);			if (theErr == noErr) {				theErr = AEPutParamDesc(&theEvent, keyDirectObject, &theObject);				AEDisposeDesc(&theObject);				if (theErr == noErr) AEAddQDRectangle(&theEvent, keyAEData, theRect);				if (theErr == noErr)					theErr = AESend(&theEvent, nil, kAENoReply + kAECanInteract, 							 kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);			}			AEDisposeDesc(&theEvent);		}	} else theErr = DoSetDrawBounds(FindImage(theWindow), theRect);	HandleAEError(theErr, 0, nil);	return theErr;}/* * SendMoveToFront(theWindow) * *     Purpose: Sends ourself an AppleEvent to move the given window to the front *      Inputs: theWindow = the window we're interested in *     Returns: nothing * */ OSErr SendMoveToFront(WindowPtr theWindow){	AEDesc theObject, theInsertionLoc, theReply;	AppleEvent theEvent;	OSErr theErr;		if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kAECoreSuite, kAEMove);		if (theErr == noErr) {			theErr = MakeWindowObject(theWindow, &theObject);			if (theErr == noErr) {				theErr = AEPutParamDesc(&theEvent, keyDirectObject, &theObject);				AEDisposeDesc(&theObject);				if (theErr == noErr) 					theErr = AEMakeBeginningILoc(&theInsertionLoc, WindowKind(theWindow) == floatingWindowKind);				if (theErr == noErr) {					theErr = AEPutParamDesc(&theEvent, keyAEInsertHere, &theInsertionLoc);					AEDisposeDesc(&theInsertionLoc);					if (theErr == noErr) {						theErr = AESend(&theEvent, &theReply, kAENoReply + kAECanInteract, 								 kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);						if (theErr != noErr) MinorError(errNoAESend);					} else MinorError(errNoAESend);				} else MinorError(errNoAESend);			} else MinorError(errNoAESend);			AEDisposeDesc(&theEvent);		} else MinorError(errNoAESend);	} else theErr = DoMoveWindow(theWindow, nil);	return theErr;}/* * SendCopy() * *     Purpose: Sends the copy AppleEvent to ourself *      Inputs: none *     Returns: nothing * */ OSErr SendCopy(void) {	ImageHandle theImage = FrontImage();	AppleEvent theEvent, theReply;	Str63 theName;	OSErr theErr;		if (gFoundOSL) {		theErr = AENewEvent(&theEvent, kAEMiscStandards, kAECopy);		if (theErr == noErr) {			theErr = AESend(&theEvent, &theReply, kAENoReply + kAECanInteract, 					 kAENormalPriority, kAEDefaultTimeout, gAEIdleProc, nil);			AEDisposeDesc(&theEvent);		}		if (theImage)			BlockMove((*theImage)->file.name, theName, *(*theImage)->file.name + 1);		HandleAEError(theErr, errNoCopyMemory, theName);	} else theErr = DoCopy();	return theErr;}