/*********************************************************//* This source code copyright (c) 1991-2001, Aaron Giles *//* See the Read Me file for licensing information.       *//* Contact email: mac@aarongiles.com                     *//*********************************************************///=====================================================================================// Generic includes for Macintosh headers//=====================================================================================#if THINK_C#include "THINK.Header"#include <stddef.h>#elif applec#pragma load ":Headers:MPW.Header"#elif __MWERKS__//#include "MW.Header"#else#include "JPEGView.h"#endif//=====================================================================================// Includes specific to this module//=====================================================================================#include "QDxDispatchPatch.h"//=====================================================================================// Constants local to this module//=====================================================================================#define _QDxDispatch 0xAB1D//=====================================================================================// Prototypes for functions local to this module//=====================================================================================static Boolean CheckForQuickTimeVM(void);//=====================================================================================// Global variables local to this module//=====================================================================================static ushort *gOnOffSwitch = nil;static ushort *gRoundGWorld = nil;static ulong *gOldTrapAddress = nil;static UniversalProcPtr gNewTrapAddress;//=====================================================================================// void InstallQDxDispatchPatch(void)//=====================================================================================// Installs a head patch to the _QDxDispatch trap that prevents any attempts at// allocating more than a 64k GWorld in temporary memory to fail.//=====================================================================================extern void InstallQDxDispatchPatch(Boolean roundGWorld){	static Boolean gFirstTime = true;	if (!HasVirtualMemory()) return;	if (gFirstTime) {		Handle theHandle;		gFirstTime = false;		if (CheckForQuickTimeVM()) return;		if (!(theHandle = GetResource(kPatchType, rQDxDispatchPatch))) return;		DetachResource(theHandle);		HLockHi(theHandle);		HNoPurge(theHandle);		gOnOffSwitch = (ushort *)StripAddress(*theHandle);		gRoundGWorld = (ushort *)(gOnOffSwitch + 1);		gOldTrapAddress = (ulong *)(gRoundGWorld + 1);		gNewTrapAddress = (UniversalProcPtr)(gOldTrapAddress + 1);		*gOldTrapAddress = (long)NGetTrapAddress(_QDxDispatch, ToolTrap);		NSetTrapAddress(gNewTrapAddress, _QDxDispatch, ToolTrap);		gMemSlop *= 2;	}	if (gOnOffSwitch) {		*gOnOffSwitch = -1;		*gRoundGWorld = roundGWorld;	}}//=====================================================================================// void RemoveQDxDispatchPatch(void)//=====================================================================================// Sets the on/off switch on our patched trap.//=====================================================================================extern void RemoveQDxDispatchPatch(void){	if (gOnOffSwitch) *gOnOffSwitch = 0;}//=====================================================================================// Boolean GetQDxDispatchPatchState(void)//=====================================================================================// Returns the on/off setting of our patched trap.//=====================================================================================extern Boolean GetQDxDispatchPatchState(void){	if (gOnOffSwitch) return (*gOnOffSwitch != 0);	return false;}//=====================================================================================// void SetQDxDispatchPatchState(Boolean on)//=====================================================================================// Sets the on/off setting of our patched trap.//=====================================================================================extern void SetQDxDispatchPatchState(Boolean on){	if (gOnOffSwitch) *gOnOffSwitch = (on) ? -1 : 0;}//=====================================================================================// void CheckForQuickTimeVM(void)//=====================================================================================// Scan the Extensions folder for a copy of the old QuickTime VM extension, and delete// any copies found there, alerting the user.  If we're in the background, however, we// don't do anything, since it's not such a great time to post a notification.//=====================================================================================static Boolean CheckForQuickTimeVM(void){	CInfoPBRec block;	Str255 fileName;	//FSSpec theSpec;	short vRefNum;	long dirID;		if (FindFolder(kOnSystemDisk, kExtensionFolderType, kDontCreateFolder, &vRefNum, 				&dirID) == noErr) {		block.hFileInfo.ioNamePtr = fileName;		block.hFileInfo.ioFDirIndex = 1;		block.hFileInfo.ioVRefNum = vRefNum;		block.hFileInfo.ioDirID = dirID;		while (PBGetCatInfo(&block, false) == noErr) {			if (block.hFileInfo.ioFlFndrInfo.fdType == 'INIT' &&				block.hFileInfo.ioFlFndrInfo.fdCreator == 'QtVm') return true;/*			{				if (!gInBackground) {					FSMakeFSSpec(vRefNum, dirID, fileName, &theSpec);					FSpDelete(&theSpec);					StopSpinning(&qd.arrow);					FWNoteAlert(CenterAlert(rQuickTimeVMAlert), gGenericFilter);					StartSpinning();				}			}*/			block.hFileInfo.ioFDirIndex++;			block.hFileInfo.ioDirID = dirID;		}	}	return false;}//=====================================================================================// Boolean HasVirtualMemory(void)//=====================================================================================// Returns true if the current system is running with virtual memory.//=====================================================================================extern Boolean HasVirtualMemory(void){	long physical, logical;	if (Gestalt(gestaltPhysicalRAMSize, &physical) == noErr &&		Gestalt(gestaltLogicalRAMSize, &logical) == noErr) {		return (physical < (logical - 512L * 1024L));	}	return false;}