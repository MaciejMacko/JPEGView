/*********************************************************//* This source code copyright (c) 1991-2001, Aaron Giles *//* See the Read Me file for licensing information.       *//* Contact email: mac@aarongiles.com                     *//*********************************************************/#if THINK_C#include "THINK.Header"#elif applec#pragma load ":Headers:MPW.Header"#elif __MWERKS__//#include "MW.Header"#else#include "JPEGView.h"#endif/* * FileAccessor(classWanted, container, containerClass, keyForm, keyData, *				resultToken, theRefCon) * *     Purpose: Finds a document according to the specified keyForm and returns the *					corresponding document token *      Inputs: classWanted = the element class desired (cFile) *				container = token for this element's container *				containerClass = class of this element's container (cDocument) *				keyForm = the search key type *				keyData = descriptor containing search key data *				resultToken = descriptor containing the resulting token *				theRefCon = reference constant *     Returns: an OSErr describing the result * */pascal OSErr FileAccessor(DescType classWanted, AEDesc *container, 	DescType containerClass, DescType keyForm, AEDesc *keyData, 	AEDesc *resultToken, long theRefCon){#if applec#pragma unused(classWanted, containerClass, theRefCon)#endif	ObjectTokenHandle theList = (ObjectTokenHandle)container->dataHandle;	OSErr theErr = noErr;		if (IsValidForOne(keyForm, keyData)) {		if ((theErr = HandToHand((Handle *)&theList)) != noErr) return theErr;	} else return errAENoSuchObject;	if (!theList || !(*theList)->count || (theErr != noErr)) {		DisposeHandle((Handle)theList);		if (theErr == noErr) theErr = errAENoSuchObject;	} else {		theErr = AECreateHandleDesc(cFile, (Handle)theList, resultToken);		DisposeHandle((Handle)theList);	}	return theErr;}/* * FilePropertyAccessor(classWanted, container, containerClass, keyForm, keyData, *					    resultToken, theRefCon) * *     Purpose: Finds a file property and returns the corresponding property token *      Inputs: classWanted = the element class desired (typeProperty) *				container = token for this element's container *				containerClass = class of this element's container (cFile) *				keyForm = the search key type *				keyData = descriptor containing search key data *				resultToken = descriptor containing the resulting token *				theRefCon = reference constant *     Returns: an OSErr describing the result * */pascal OSErr FilePropertyAccessor(DescType classWanted, AEDesc *container, 	DescType containerClass, DescType keyForm, AEDesc *keyData, 	AEDesc *resultToken, long theRefCon){#if applec#pragma unused(classWanted, containerClass, theRefCon)#endif	ObjectTokenHandle theList = (ObjectTokenHandle)container->dataHandle;	DescType propertyType;	OSErr theErr;		if ((keyForm != formPropertyID) || (keyData->descriptorType != typeType))		return errAECantSupplyType;	propertyType = *(DescType *)*keyData->dataHandle;	switch (propertyType) {		// Non-modifiable properties		case pBestType:		case pClass:		case pDefaultType:		case pIsStationeryPad:		// Modifiable properties		case pName:			break;		default:			return errAEEventNotHandled;	}	theErr = HandToHand((Handle *)&theList);	if (theErr != noErr) return theErr;	(*theList)->property = propertyType;	(*theList)->objclass = cFile;	theErr = AECreateHandleDesc(typeProperty, (Handle)theList, resultToken);	DisposeHandle((Handle)theList);	return theErr;}/* * GetFileData(theWindow, typeWanted, theData) * *     Purpose: Extracts the data from the file *      Inputs: theWindow = the window associated with this object *				typeWanted = the type we're asking for *				theData = the data we save *     Returns: an OSErr describing the result * */OSErr GetFileData(WindowPtr theWindow, DescType typeWanted, AEDesc *theData){	if (typeWanted == typeWildCard) typeWanted = typeObjectSpecifier;	if (typeWanted == typeBest) typeWanted = typeObjectSpecifier;	if (typeWanted != typeObjectSpecifier) return errAECantSupplyType;	return MakeFileObject(theWindow, theData);}/* * GetFilePropertyData(theWindow, theProperty, typeWanted, theData) * *     Purpose: Extracts the data from the file's properties *      Inputs: theWindow = the window associated with this object *				theProperty = the property wanted *				typeWanted = the type we're asking for *				theData = the data we save *     Returns: an OSErr describing the result * */OSErr GetFilePropertyData(WindowPtr theWindow, DescType theProperty, DescType typeWanted, 	AEDesc *theData){	ImageHandle theImage = FindImage(theWindow);	Boolean theBoolean = false;	Handle theHandle;	DescType theType;	AEDesc bestData;	FSSpec theSpec;	long theLong;	OSErr theErr;		if (!theImage) return errAEReadDenied;	switch (theProperty) {		case pBestType:		case pDefaultType:			theType = typeObjectSpecifier;			theErr = AECreateDesc(typeType, (void *)&theType, sizeof(DescType), &bestData);			break;		case pClass:			theType = cFile;			theErr = AECreateDesc(typeType, (void *)&theType, sizeof(DescType), &bestData);			break;		case pIsStationeryPad:			theErr = AECreateDesc(typeBoolean, (void *)&theBoolean, sizeof(Boolean), &bestData);			break;		case pName:			theSpec = (*theImage)->file;			theErr = GetFullPath(&theSpec, &theHandle);			if ((theErr == noErr) && theHandle) {				theLong = GetHandleSize(theHandle);				SetHandleSize(theHandle, theLong + 4);				if ((theErr = MemError()) == noErr) {					BlockMove(*theHandle, (uchar *)*theHandle + 4, theLong);					*(short *)*theHandle = smCurrentScript;					*((short *)*theHandle + 1) = currentCurLang;					theErr = AECreateHandleDesc(typeIntlText, theHandle, &bestData);				}				DisposeHandle(theHandle);			}			break;		default:			return errAETypeError;	}	if (theErr != noErr) return theErr;	if ((bestData.descriptorType == typeWanted) ||		(typeWanted == typeWildCard) || (typeWanted == typeBest))		theErr = AEDuplicateDesc(&bestData, theData);	else theErr = AECoerceDesc(&bestData, typeWanted, theData);	AEDisposeDesc(&bestData);	return theErr;}/* * SetFilePropertyData(theWindow, theProperty, theData) * *     Purpose: Sets the data for the application's properties *      Inputs: theWindow = the associated window *				theProperty = the property wanted *				theData = the data to set it to *     Returns: an OSErr describing the result * */OSErr SetFilePropertyData(WindowPtr theWindow, DescType theProperty, AEDesc *theData){	ImageHandle theImage = FindImage(theWindow);	Str255 theString;	FSSpec theSpec;	OSErr theErr;	if (!theImage) return errAEReadDenied;	switch (theProperty) {		case pName:			theErr = AEExtractPString(theData, 0, theString);			if (theErr == noErr) {				theErr = FSMakeFSSpec((*theImage)->file.vRefNum, (*theImage)->file.parID,						 theString, &theSpec);				if ((theErr == noErr) || (theErr == fnfErr)) {					(*theImage)->file = theSpec;					theErr = noErr;				}			}			break;		default:			theErr = errAEWriteDenied;			break;	}	return theErr;}/* * MakeFileObject(theWindow, theObject) * *     Purpose: Creates a file object descriptor for the given window *      Inputs: theWindow = pointer to the window, or nil for all windows *				theObject = pointer to an AEDesc to store the result *     Returns: an OSErr describing what went wrong * */OSErr MakeFileObject(WindowPtr theWindow, AEDesc *theObject){	AEDesc theKey, theContainer;	long index = kAEFirst;	OSErr theErr = noErr;		theErr = MakeDocumentObject(theWindow, &theContainer);	if (theErr == noErr) {		theErr = AECreateDesc(typeAbsoluteOrdinal, (void *)&index, sizeof(long), &theKey);		if (theErr == noErr) {			theErr = CreateObjSpecifier(cFile, &theContainer, formAbsolutePosition, 					 &theKey, false, theObject);			AEDisposeDesc(&theKey);		}		AEDisposeDesc(&theContainer);	}	return theErr;}/* * MakeFilePropertyObject(theWindow, theProperty, theObject) * *     Purpose: Creates a property object descriptor for the given files's property *      Inputs: theWindow = pointer to the window, or nil for all windows *				theObject = pointer to an AEDesc to store the result *     Returns: an OSErr describing what went wrong * */OSErr MakeFilePropertyObject(WindowPtr theWindow, DescType theProperty, AEDesc *theObject){	AEDesc theKey, theContainer;	OSErr theErr = noErr;		theErr = MakeFileObject(theWindow, &theContainer);	if (theErr == noErr) {		theErr = AECreateDesc(typeType, (void *)&theProperty, sizeof(DescType), &theKey);		if (theErr == noErr) {			theErr = CreateObjSpecifier(typeProperty, &theContainer, formPropertyID, 					 &theKey, false, theObject);			AEDisposeDesc(&theKey);		}		AEDisposeDesc(&theContainer);	}	return theErr;}