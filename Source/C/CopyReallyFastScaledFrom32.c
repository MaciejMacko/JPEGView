/*********************************************************//* This source code copyright (c) 1991-2001, Aaron Giles *//* See the Read Me file for licensing information.       *//* Contact email: mac@aarongiles.com                     *//*********************************************************/// void CopyScaledFrom32(CopyDataPtr theData);#define One (1L << 16)	DitherErrorsPtr eBuffer,			// pointers to whichever dithering					oBuffer;			// 		buffers we decide to use	ulong *scaled,				 		// pointer to the start of the scaling buffer		  *srcScaled, 					// temp. source pointer used during scaling		  *dstScaled;					// destination pointer used during scaling	Ptr src = theData->srcBase, 		// source pointer into original image data		dst = theData->dstBase;			// dest. pointer into real destination	ulong srcPixelContributionY, 		// contribution in Y made by each source pixel		  srcPixelContributionX, 		// contribution in X made by each source pixel		  srcRemainingY = theData->yRemainder,// remaining Y contribution for source		  srcRemainingX;				// remaining X contribution for current src	ulong dstNeededY, 					// amount needed for complete dest. Y pixel		  dstNeededX;					// amount needed for complete dest. X pixel	short *rgnPtr; 						// pointer to the region data	long row = theData->height, 		// row counter		  col;							// column counter	Handle dynamicBuffer;				// handle to any allocation we make	RgnBuffer rgnData;					// buffer for the region data	DitherErrors evenDithering[kStackRowWidth + 2], 	// stack-based buffers for dithering; if these				 oddDithering[kStackRowWidth + 2];	// 		aren't enough, we allocate bigger ones	ulong scaledRow[kStackRowWidth + 2];				// stack-based buffer for scaling	// Allocate space for our buffers, if not enough room on stack	// NOTE: This only works if the machine is in 32-bit addressing mode!!!	if (theData->width > kStackRowWidth) {		dynamicBuffer = AnyNewHandle((theData->width + 2) * (2 * sizeof(DitherErrors) + sizeof(ulong)));		if (!dynamicBuffer) return;		HLock(dynamicBuffer);		eBuffer = (DitherErrorsPtr)*dynamicBuffer + 1;		oBuffer = eBuffer + theData->width + 2;		scaled = (ulong *)(oBuffer + theData->width + 1) + 1;	} else {		eBuffer = &evenDithering[1];		oBuffer = &oddDithering[1];	}	scaled = &scaledRow[1];		// Clear out the dithering and scaling buffers	if (theData->evodd & 1) 		ClearMem((Ptr)&eBuffer[-1], (theData->width + 2) * sizeof(DitherErrors));	else ClearMem((Ptr)&oBuffer[-1], (theData->width + 2) * sizeof(DitherErrors));		// Initialize the region data	rgnData.zero = 0;	rgnPtr = InitRegion(*theData->theRgn, &rgnData, &theData->boxRect);		// Set up the source/destination quantities	srcPixelContributionY = (theData->dstHeight << 16) / theData->srcHeight + 1;	srcPixelContributionX = (theData->dstWidth << 16) / theData->srcWidth + 1;	// The outermost (row) loop begins here; set up our pointers into the data	while (row--) {		srcScaled = (ulong *)src;		dstScaled = (ulong *)scaled;			// reset the columns counter and reset the source X remainder		col = theData->width;		srcRemainingX = theData->xRemainder;		// The inner (column) loops begin here; set up our counters in the dest system		if (One >= srcRemainingY) {			if ((One - srcRemainingY) < srcPixelContributionY)				srcScaled += ((One - srcRemainingY) < srcRemainingY) ?							0 : (theData->srcRow >> 2);			else srcScaled += (theData->srcRow >> 2);		}		while (col--) {			dstNeededX = One;			if (dstNeededX < srcRemainingX)				*dstScaled++ = *srcScaled;			else if ((dstNeededX -= srcRemainingX) < srcPixelContributionX) {				if (dstNeededX < srcRemainingX) *dstScaled++ = *srcScaled++;				else *dstScaled++ = *++srcScaled;				srcRemainingX = srcPixelContributionX;			} else {				*dstScaled++ = *++srcScaled;				srcScaled++;			ScaleLoop1:				if ((dstNeededX -= srcPixelContributionX) >= srcPixelContributionX) {					srcScaled++;					goto ScaleLoop1;				}				srcRemainingX = srcPixelContributionX;			}			// apply the final adjustment to the X counters			srcRemainingX -= dstNeededX;		}				// We now have a row; set up to do a dithered copy from it		if ((++theData->evodd) & 1)			theData->odd(scaled, dst, theData->itAddr, theData->ctAddr, eBuffer, oBuffer,						 rgnData.buffer, theData->errTable, theData->width);		else theData->even(scaled, dst, theData->itAddr, theData->ctAddr, eBuffer, oBuffer,						 rgnData.buffer, theData->errTable, theData->width);		if (!row) break;		if (!--rgnData.yCount) rgnPtr = UpdateRegion(rgnPtr, &rgnData, &theData->boxRect);		// apply final adjustments to the Y counters		dstNeededY = 1L << 16;		while (dstNeededY >= srcRemainingY) {			src += theData->srcRow;			dstNeededY -= srcRemainingY;			srcRemainingY = srcPixelContributionY;		}		srcRemainingY -= dstNeededY;		dst += theData->dstRow;	}		// Return space allocated for buffers	if (theData->width > kStackRowWidth) DisposeHandle(dynamicBuffer);