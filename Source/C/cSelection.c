/*********************************************************//* This source code copyright (c) 1991-2001, Aaron Giles *//* See the Read Me file for licensing information.       *//* Contact email: mac@aarongiles.com                     *//*********************************************************/#if THINK_C#include "THINK.Header"#elif applec#pragma load ":Headers:MPW.Header"#elif __MWERKS__//#include "MW.Header"#else#include "JPEGView.h"#endif/* * SelectionAccessor(classWanted, container, containerClass, keyForm, keyData, *				resultToken, theRefCon) * *     Purpose: Finds a selection according to the specified keyForm and returns the *					corresponding selection token *      Inputs: classWanted = the element class desired (cSelection) *				container = token for this element's container *				containerClass = class of this element's container (typeProperty) *				keyForm = the search key type *				keyData = descriptor containing search key data *				resultToken = descriptor containing the resulting token *				theRefCon = reference constant *     Returns: an OSErr describing the result * */pascal OSErr SelectionAccessor(DescType classWanted, AEDesc *container, 	DescType containerClass, DescType keyForm, AEDesc *keyData, 	AEDesc *resultToken, long theRefCon){#if applec#pragma unused(classWanted, containerClass, keyForm, keyData, theRefCon)#endif	ObjectTokenHandle theList = (ObjectTokenHandle)container->dataHandle;	OSErr theErr = noErr;	if ((theErr = HandToHand((Handle *)&theList)) != noErr) return theErr;	if (!theList || !(*theList)->count || (theErr != noErr)) {		DisposeHandle((Handle)theList);		if (theErr == noErr) theErr = errAENoSuchObject;	} else {		theErr = AECreateHandleDesc(cSelection, (Handle)theList, resultToken);		DisposeHandle((Handle)theList);	}	return theErr;}/* * SelPropertyAccessor(classWanted, container, containerClass, keyForm, keyData, *					    resultToken, theRefCon) * *     Purpose: Finds a file property and returns the corresponding property token *      Inputs: classWanted = the element class desired (typeProperty) *				container = token for this element's container *				containerClass = class of this element's container (cSelection) *				keyForm = the search key type *				keyData = descriptor containing search key data *				resultToken = descriptor containing the resulting token *				theRefCon = reference constant *     Returns: an OSErr describing the result * */pascal OSErr SelPropertyAccessor(DescType classWanted, AEDesc *container, 	DescType containerClass, DescType keyForm, AEDesc *keyData, 	AEDesc *resultToken, long theRefCon){#if applec#pragma unused(classWanted, containerClass, theRefCon)#endif	ObjectTokenHandle theList = (ObjectTokenHandle)container->dataHandle;	DescType propertyType;	OSErr theErr;		if ((keyForm != formPropertyID) || (keyData->descriptorType != typeType))		return errAECantSupplyType;	propertyType = *(DescType *)*keyData->dataHandle;	switch (propertyType) {		// Non-modifiable properties		case pBestType:		case pClass:		case pDefaultType:		// Modifiable properties		case pBounds:			break;		default:			return errAEEventNotHandled;	}	theErr = HandToHand((Handle *)&theList);	if (theErr != noErr) return theErr;	(*theList)->property = propertyType;	(*theList)->objclass = cSelection;	theErr = AECreateHandleDesc(typeProperty, (Handle)theList, resultToken);	DisposeHandle((Handle)theList);	return theErr;}/* * GetSelectionData(theWindow, typeWanted, theData) * *     Purpose: Extracts the data from the selection *      Inputs: theWindow = the window associated with this object *				typeWanted = the type we're asking for *				theData = the data we save *     Returns: an OSErr describing the result * */OSErr GetSelectionData(WindowPtr theWindow, DescType typeWanted, AEDesc *theData){	if (typeWanted == typeWildCard) typeWanted = typeObjectSpecifier;	if (typeWanted == typeBest) typeWanted = typeObjectSpecifier;	if (typeWanted != typeObjectSpecifier) return errAECantSupplyType;	return MakeSelectionObject(theWindow, theData);}/* * GetSelPropertyData(theWindow, theProperty, typeWanted, theData) * *     Purpose: Extracts the data from the selection's properties *      Inputs: theWindow = the window associated with this object *				theProperty = the property wanted *				typeWanted = the type we're asking for *				theData = the data we save *     Returns: an OSErr describing the result * */OSErr GetSelPropertyData(WindowPtr theWindow, DescType theProperty, DescType typeWanted, 	AEDesc *theData){	ImageHandle theImage = FindImage(theWindow);	DescType theType;	AEDesc bestData;	OSErr theErr;	Rect theRect;		switch (theProperty) {		case pBestType:		case pDefaultType:			theType = typeObjectSpecifier;			theErr = AECreateDesc(typeType, (void *)&theType, sizeof(DescType), &bestData);			break;		case pClass:			theType = cSelection;			theErr = AECreateDesc(typeType, (void *)&theType, sizeof(DescType), &bestData);			break;		case pBounds:			GetAntsSelection((*theImage)->ants, &theRect);			theErr = AECreateDesc(typeQDRectangle, (void *)&theRect, sizeof(Rect), &bestData);			break;		default:			return errAETypeError;	}	if (theErr != noErr) return theErr;	if ((bestData.descriptorType == typeWanted) ||		(typeWanted == typeWildCard) || (typeWanted == typeBest))		theErr = AEDuplicateDesc(&bestData, theData);	else theErr = AECoerceDesc(&bestData, typeWanted, theData);	AEDisposeDesc(&bestData);	return theErr;}/* * SetSelPropertyData(theWindow, theProperty, theData) * *     Purpose: Sets the data for the selection's properties *      Inputs: theWindow = the associated window *				theProperty = the property wanted *				theData = the data to set it to *     Returns: an OSErr describing the result * */OSErr SetSelPropertyData(WindowPtr theWindow, DescType theProperty, AEDesc *theData){	ImageHandle theImage = FindImage(theWindow);	Rect theRect;	OSErr theErr;	switch (theProperty) {		case pBounds:			theErr = AEExtractQDRectangle(theData, 0, &theRect);			if (theErr == noErr && theImage) theErr = DoSetSelection(theImage, &theRect);			break;		default:			theErr = errAEWriteDenied;			break;	}	return theErr;}/* * MakeSelectionObject(theWindow, theObject) * *     Purpose: Creates a selection object descriptor for the given window *      Inputs: theWindow = pointer to the window, or nil for all windows *				theObject = pointer to an AEDesc to store the result *     Returns: an OSErr describing what went wrong * */OSErr MakeSelectionObject(WindowPtr theWindow, AEDesc *theObject){	long index = kAEFirst;	OSErr theErr = noErr;		return MakeWinPropertyObject(theWindow, pSelection, theObject);}/* * MakeSelPropertyObject(theWindow, theProperty, theObject) * *     Purpose: Creates a property object descriptor for the given selection's property *      Inputs: theWindow = pointer to the window, or nil for all windows *				theObject = pointer to an AEDesc to store the result *     Returns: an OSErr describing what went wrong * */OSErr MakeSelPropertyObject(WindowPtr theWindow, DescType theProperty, AEDesc *theObject){	AEDesc theKey, theContainer;	OSErr theErr = noErr;		theErr = MakeSelectionObject(theWindow, &theContainer);	if (theErr == noErr) {		theErr = AECreateDesc(typeType, (void *)&theProperty, sizeof(DescType), &theKey);		if (theErr == noErr) {			theErr = CreateObjSpecifier(typeProperty, &theContainer, formPropertyID, 					 &theKey, false, theObject);			AEDisposeDesc(&theKey);		}		AEDisposeDesc(&theContainer);	}	return theErr;}extern OSErr DoSetSelection(ImageHandle theImage, Rect *theRect){	SetAntsSelection((*theImage)->ants, theRect);	ShowAnts((*theImage)->ants);	return noErr;}