/*********************************************************//* This source code copyright (c) 1991-2001, Aaron Giles *//* See the Read Me file for licensing information.       *//* Contact email: mac@aarongiles.com                     *//*********************************************************/// void CopyScaledFrom32(CopyDataPtr theData);#define AddPixel(source, factor) \	pixel = (source),\	blue += factor * (pixel & 0xff),\	pixel >>= 8,\	green += factor * (pixel & 0xff),\	pixel >>= 8,\	red += factor * (pixel & 0xff)	DitherErrors evenDithering[1952], 	// stack-based buffers for dithering; if these				 oddDithering[1952];	// 		aren't enough, we allocate bigger ones	DitherErrorsPtr eBuffer = &evenDithering[1],// pointers to whichever dithering					oBuffer = &oddDithering[1];	// 		buffers we decide to use	ulong scaledRow[1952];				// stack-based buffer for scaling	ulong *scaled = &scaledRow[1], 		// pointer to the start of the scaling buffer		  *srcScaled, 					// temp. source pointer used during scaling		  *dstScaled;					// destination pointer used during scaling	Ptr src = theData->srcBase, 		// source pointer into original image data		dst = theData->dstBase;			// dest. pointer into real destination	float srcPixelContributionY, 		// contribution in Y made by each source pixel		  srcPixelContributionX, 		// contribution in X made by each source pixel		  srcRemainingY = (float)theData->yRemainder / 1024.0,// remaining Y contribution for source		  srcRemainingX;				// remaining X contribution for current src	float xRemainderFloat = (float)theData->xRemainder / 1024.0;	float dstNeededY, 					// amount needed for complete dest. Y pixel		  dstNeededX;					// amount needed for complete dest. X pixel	float red, green, blue;	ulong pixel;		// temp. counter for rgb and holder for pixel	short *rgnPtr, 						// pointer to the region data		  row = theData->height, 		// row counter		  col;							// column counter	Handle dynamicBuffer;				// handle to any allocation we make	RgnBuffer rgnData;					// buffer for the region data		// Allocate space for our buffers, if not enough room on stack	// NOTE: This only works if the machine is in 32-bit addressing mode!!!	if (theData->width > 1950) {		dynamicBuffer = AnyNewHandle((theData->width + 2) * (2 * sizeof(DitherErrors) + sizeof(ulong)));		if (!dynamicBuffer) return;		HLock(dynamicBuffer);		eBuffer = (DitherErrorsPtr)*dynamicBuffer + 1;		oBuffer = eBuffer + theData->width + 2;		scaled = (ulong *)(oBuffer + theData->width + 1) + 1;	}		// Clear out the dithering and scaling buffers	ClearMem((Ptr)&eBuffer[-1], (theData->width + 2) * sizeof(DitherErrors));	ClearMem((Ptr)&oBuffer[-1], (theData->width + 2) * sizeof(DitherErrors));	ClearMem((Ptr)&scaled[-1], (theData->width + 2) * sizeof(ulong));		// Initialize the region data	rgnData.zero = 0;	rgnPtr = InitRegion(*theData->theRgn, &rgnData, &theData->boxRect);		// Set up the source/destination quantities	srcPixelContributionY = (float)theData->dstHeight / (float)theData->srcHeight;	srcPixelContributionX = (float)theData->dstWidth / (float)theData->srcWidth;	// The outermost (row) loop begins here; set up our pointers into the data	while (row--) {		srcScaled = (ulong *)src;		dstScaled = (ulong *)scaled;			// reset the columns counter and reset the source X remainder		col = theData->width;		srcRemainingX = xRemainderFloat;		// The inner (column) loop begins here; set up our counters in the dest system		while (col--) {			dstNeededX = dstNeededY = 1.0;			red = green = blue = 0.0;						// Determine what sort of scaling is best for us			if (dstNeededY < srcRemainingY && dstNeededX < srcRemainingX) {								// no scaling needed for this particular destination pixel				*dstScaled++ = *srcScaled;				goto dontStore;			} else if (dstNeededY < srcRemainingY) {				// scaling needed in the X direction only				do {					red += ((uchar *)srcScaled)[1] * srcRemainingX;					green += ((uchar *)srcScaled)[2] * srcRemainingX;					blue += ((uchar *)srcScaled)[3] * srcRemainingX;					srcScaled++;					dstNeededX -= srcRemainingX;					srcRemainingX = srcPixelContributionX;				} while (dstNeededX > srcRemainingX);				red += ((uchar *)srcScaled)[1] * dstNeededX;				green += ((uchar *)srcScaled)[2] * dstNeededX;				blue += ((uchar *)srcScaled)[3] * dstNeededX;				dstNeededX -= srcRemainingX;				srcRemainingX = srcPixelContributionX;			} else if (dstNeededX < srcRemainingX) {				// scaling needed in the Y direction only				float origSrcRemainingY = srcRemainingY;				ulong *srcStart = srcScaled;				do {					red += ((uchar *)srcScaled)[1] * srcRemainingY;					green += ((uchar *)srcScaled)[2] * srcRemainingY;					blue += ((uchar *)srcScaled)[3] * srcRemainingY;					srcScaled += (theData->srcRow >> 2);					dstNeededY -= srcRemainingY;					srcRemainingY = srcPixelContributionY;				} while (dstNeededY > srcRemainingY);				if (dstNeededY) {					red += ((uchar *)srcScaled)[1] * dstNeededY;					green += ((uchar *)srcScaled)[2] * dstNeededY;					blue += ((uchar *)srcScaled)[3] * dstNeededY;				}				srcScaled = srcStart;				srcRemainingY = origSrcRemainingY;			} else {				// scaling needed in both directions				float multiplier, origSrcRemainingX = srcRemainingX;				float origSrcRemainingY = srcRemainingY;				ulong *srcStart = srcScaled, *srcRowStart;								do {					srcRowStart = srcScaled;										do {						multiplier = srcRemainingX * srcRemainingY;						red += ((uchar *)srcScaled)[1] * multiplier;						green += ((uchar *)srcScaled)[2] * multiplier;						blue += ((uchar *)srcScaled)[3] * multiplier;						srcScaled++;						dstNeededX -= srcRemainingX;						srcRemainingX = srcPixelContributionX;					} while (dstNeededX > srcRemainingX);										multiplier = dstNeededX * srcRemainingY;					red += ((uchar *)srcScaled)[1] * multiplier;					green += ((uchar *)srcScaled)[2] * multiplier;					blue += ((uchar *)srcScaled)[3] * multiplier;					srcRemainingX = origSrcRemainingX;					dstNeededX = 1.0;					srcScaled = srcRowStart + (theData->srcRow >> 2);					dstNeededY -= srcRemainingY;					srcRemainingY = srcPixelContributionY;				} while (dstNeededY > srcRemainingY);								do {					multiplier = srcRemainingX * dstNeededY;					red += ((uchar *)srcScaled)[1] * multiplier;					green += ((uchar *)srcScaled)[2] * multiplier;					blue += ((uchar *)srcScaled)[3] * multiplier;					srcScaled++;					srcStart++;					dstNeededX -= srcRemainingX;					srcRemainingX = srcPixelContributionX;				} while (dstNeededX > srcRemainingX);								multiplier = dstNeededX * dstNeededY;				red += ((uchar *)srcScaled)[1] * multiplier;				green += ((uchar *)srcScaled)[2] * multiplier;				blue += ((uchar *)srcScaled)[3] * multiplier;				srcScaled = srcStart;				srcRemainingY = origSrcRemainingY;			}			pixel = (uchar)red;			pixel <<= 8;			pixel |= (uchar)green;			pixel <<= 8;			pixel |= (uchar)blue;			*dstScaled++ = pixel;			// apply the final adjustment to the X counters		dontStore:			if (!(srcRemainingX -= dstNeededX)) {				srcScaled++;				srcRemainingX = srcPixelContributionX;			}		}				// We now have a row; set up to do a dithered copy from it		if ((++theData->evodd) & 1)			theData->odd(scaled, dst, theData->itAddr, theData->ctAddr, eBuffer, oBuffer,						 rgnData.buffer, theData->errTable, theData->width);		else theData->even(scaled, dst, theData->itAddr, theData->ctAddr, eBuffer, oBuffer,						 rgnData.buffer, theData->errTable, theData->width);		if (!row) break;		if (!--rgnData.yCount) rgnPtr = UpdateRegion(rgnPtr, &rgnData, &theData->boxRect);		// apply final adjustments to the Y counters		dstNeededY = 1.0;		while (dstNeededY >= srcRemainingY) {			src += theData->srcRow;			dstNeededY -= srcRemainingY;			srcRemainingY = srcPixelContributionY;		}		srcRemainingY -= dstNeededY;		dst += theData->dstRow;	}		// Return space allocated for buffers	if (theData->width > 1950) DisposeHandle(dynamicBuffer);