/*********************************************************//* This source code copyright (c) 1991-2001, Aaron Giles *//* See the Read Me file for licensing information.       *//* Contact email: mac@aarongiles.com                     *//*********************************************************/#if THINK_C#include "THINK.Header"#elif applec#pragma load ":Headers:MPW.Header"#elif __MWERKS__//#include "MW.Header"#else#include "JPEGView.h"#endif/* * HandleViewChoice(theItem) * *     Purpose: Accepts menu events from the View menu *      Inputs: theItem = the menu item number *     Returns: nothing * */void HandleViewChoice(short theItem) {	ImageHandle theImage = FrontImage();	Rect newRect, theRect, tmpRect;	MonitorHandle mostMonitor;		if (!theImage) return;	newRect = (*theImage)->wrect;	GlobalRect(&newRect, (*theImage)->window);	mostMonitor = GetMostDevice(&newRect);	OffsetRect(&newRect, -newRect.left, -newRect.top);	switch (theItem) {		case viewFullScreenItem:			(*theImage)->dmon = mostMonitor;			SendSetFullScreen((*theImage)->window, !Full(theImage));			break;		case viewResizeItem:			(*theImage)->dmon = mostMonitor;			newRect = (*theImage)->crect;			ScaleRect(&newRect, (*theImage)->dmon, Full(theImage), gThePrefs.expandSmall);			SendSetDrawBounds((*theImage)->window, &newRect);			break;		case viewNormalItem:			GetActiveRect((*theImage)->dmon, &newRect);			if (!Full(theImage)) newRect.top += gTitleBarHeight;			if ((Width(&(*theImage)->crect) <= Width(&newRect)) &&				(Height(&(*theImage)->crect) <= Height(&newRect))) {				newRect = (*theImage)->crect;				SendSetDrawBounds((*theImage)->window, &newRect);			} else HandleViewChoice(viewMaxItem);			break;		case viewHalfItem:			newRect.right >>= 1;			newRect.bottom >>= 1;			SendSetDrawBounds((*theImage)->window, &newRect);			break;		case viewDoubleItem:			newRect.right <<= 1;			newRect.bottom <<= 1;			SendSetDrawBounds((*theImage)->window, &newRect);			break;		case viewMaxItem:			newRect = (*theImage)->crect;			OffsetRect(&newRect, -newRect.left, -newRect.top);			GetActiveRect(mostMonitor, &theRect);			if (!Full(theImage)) theRect.top += gTitleBarHeight;			newRect.right = (long)newRect.right * (long)Height(&theRect) / (long)newRect.bottom;			newRect.bottom = Height(&theRect);			if (Width(&newRect) > Width(&theRect)) {				newRect.bottom = (long)newRect.bottom * (long)Width(&theRect) / (long)newRect.right;				newRect.right = Width(&theRect);			}			SendSetDrawBounds((*theImage)->window, &newRect);			break;		case viewShrinkItem:			newRect.right -= newRect.right / 10;			newRect.bottom -= newRect.bottom / 10;			SendSetDrawBounds((*theImage)->window, &newRect);			break;		case viewExpandItem:			newRect.right += newRect.right / 10;			newRect.bottom += newRect.bottom / 10;			SendSetDrawBounds((*theImage)->window, &newRect);			break;	}}/* * ForceScreenSize(srcRect) * *     Purpose: Tries to force srcRect to be exactly screen-sized *      Inputs: srcRect = the rectangle to fit *     Returns: nothing * */ void ForceScreenSize(ImageHandle theImage, Rect *srcRect){	Rect srect, crect = (*theImage)->crect;		GetActiveRect((*theImage)->dmon, &srect);	if (!Full(theImage)) srect.top += gTitleBarHeight;	while ((Width(srcRect) < Width(&srect)) && (Width(srcRect) <= Width(&crect))) {		if ((crect.right - srcRect->right) > (crect.left - srcRect->left)) srcRect->right++;		else srcRect->left--;	}	while ((Width(srcRect) > Width(&srect)) || (Width(srcRect) > Width(&crect))) {		if ((crect.right - srcRect->right) > (crect.left - srcRect->left)) srcRect->right--;		else srcRect->left++;	}	while ((Height(srcRect) < Height(&srect)) && (Height(srcRect) <= Height(&crect))) {		if ((crect.bottom - srcRect->bottom) > (crect.top - srcRect->top)) srcRect->bottom++;		else srcRect->top--;	}	while ((Height(srcRect) > Height(&srect)) || (Height(srcRect) > Height(&crect))) {		if ((crect.bottom - srcRect->bottom) > (crect.top - srcRect->top)) srcRect->bottom--;		else srcRect->top++;	}	if (srcRect->left < crect.left) srcRect->left = crect.left;	if (srcRect->right > crect.right) srcRect->right = crect.right;	if (srcRect->top < crect.top) srcRect->top = crect.top;	if (srcRect->bottom > crect.bottom) srcRect->bottom = crect.bottom;}