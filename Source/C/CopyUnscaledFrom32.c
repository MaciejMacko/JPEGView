/*********************************************************//* This source code copyright (c) 1991-2001, Aaron Giles *//* See the Read Me file for licensing information.       *//* Contact email: mac@aarongiles.com                     *//*********************************************************/// void CopyUnscaledFrom32(CopyDataPtr theData);	DitherErrorsPtr eBuffer, oBuffer;	Ptr src = theData->srcBase, dst = theData->dstBase;	short *rgnPtr;	long row = theData->height;	Handle dynamicBuffer;	RgnBuffer rgnData;	DitherErrors evenDithering[kStackRowWidth + 2];	DitherErrors oddDithering[kStackRowWidth + 2];		// Allocate space for our buffers, if not enough room on stack	// NOTE: This only works if the machine is in 32-bit addressing mode!!!	if (theData->width > kStackRowWidth) {		dynamicBuffer = AnyNewHandle((theData->width + 2) * 2 * sizeof(DitherErrors));		if (!dynamicBuffer) return;		HLock(dynamicBuffer);		eBuffer = (DitherErrorsPtr)*dynamicBuffer + 1;		oBuffer = eBuffer + theData->width + 2;	} else {		eBuffer = &evenDithering[1];		oBuffer = &oddDithering[1];	}	// Clear out the dithering buffers	if (theData->evodd & 1) 		ClearMem((Ptr)&eBuffer[-1], (theData->width + 2) * sizeof(DitherErrors));	else ClearMem((Ptr)&oBuffer[-1], (theData->width + 2) * sizeof(DitherErrors));		// Initialize the region data	rgnData.zero = 0;	rgnPtr = InitRegion(*theData->theRgn, &rgnData, &theData->boxRect);		// Beginning of outer (row) loop: determine even/odd and dither	while (row--) {		if ((++theData->evodd) & 1)			theData->odd((ulong *)src, dst, theData->itAddr, theData->ctAddr, eBuffer, 						oBuffer, rgnData.buffer, theData->errTable, theData->width);		else theData->even((ulong *)src, dst, theData->itAddr, theData->ctAddr, eBuffer, 						oBuffer, rgnData.buffer, theData->errTable, theData->width);		if (!row) break;		if (!--rgnData.yCount) rgnPtr = UpdateRegion(rgnPtr, &rgnData, &theData->boxRect);		src += theData->srcRow;		dst += theData->dstRow;	}	// Return space allocated for buffers	if (theData->width > kStackRowWidth) DisposeHandle(dynamicBuffer);/*	// Needed for all copy routines0	ColorSpec *ctAddr;		// color table address4	uchar *itAddr; 			// inverse color table address8	DitherErrorsPtr evenAddr,// even dithering buffer12		oddAddr;			// odd dithering buffer16	DitherToDestPtr even,	// address of even row dithering routine20		odd;	 			// address of odd row dithering routine24	short *errTable;		// address of dithering table28	long srcRow, 			// row bytes in source pixmap32		dstRow; 			// row bytes in destination pixmap36	Ptr srcBase, 			// base address of source pixmap40		dstBase;			// base address of destination pixmap44	long rgnBuffer[512],2092	width,	 			// total width of image2096	height,				// total height of image2100	evodd;				// word holding the even/odd row status2104RgnHandle theRgn;		// handle to the clipping region2108Rect boxRect;			// outer rect of the region	// Needed only for CopyScaled routines	long srcHeight, 		// height of the source rectangle		srcWidth, 			// width of same		dstHeight, 			// height of the destination rectangle		dstWidth,			// width of same		xRemainder, 		// starting remainder in x		yRemainder, 		// starting remainder in y		columns, 			// internal counter for columns		rows;				// internal counter for rows	Ptr outputAddr,			// internal holder for destination address		sTable[6];			// pointers into the scaling table} CopyData, *CopyDataPtr, **CopyDataHandle;	DitherErrorsPtr eBuffer, oBuffer;	Ptr src = theData->srcBase, dst = theData->dstBase;	short *rgnPtr;	long row = theData->height;	Handle dynamicBuffer;	RgnBuffer rgnData;	DitherErrors evenDithering[1752], oddDithering[1752];	00000000: 7C0802A6  mflr     r000000004: BF01FFE0  stmw     r24,-32(SP)00000008: 90010008  stw      r0,8(SP)0000000C: 94215950  stwu     SP,22864(SP)00000010: 7C7F1B78  mr       theData,r300000014: 807F082C  lwz      r3,2092(theData)	;theData->width00000018: 83DF0024  lwz      src,36(theData)	;theData->srcBase0000001C: 2C0306D6  cmpwi    r3,175000000020: 83BF0028  lwz      dst,40(theData)	;theData->dstBase00000024: 833F0830  lwz      row,2096(theData)	;theData->height00000028: 40810050  ble      *+80                    ; $00000078	if (theData->width > 1750) {		dynamicBuffer = AnyNewHandle((theData->width + 2) * 2 * sizeof(DitherErrors));		if (!dynamicBuffer) return;		HLock(dynamicBuffer);		eBuffer = (DitherErrorsPtr)*dynamicBuffer + 1;		oBuffer = eBuffer + theData->width + 2;0000002C: 809F082C  lwz      r4,2092(theData)	;theData->width00000030: 38840002  addi     r4,r4,200000034: 5484083C  slwi     r4,r4,100000038: 1C64000C  mulli    r3,r4,120000003C: 48000001  bl       .AnyNewHandle00000040: 60000000  nop00000044: 7C781B78  mr       dynamicBuffer,r300000048: 2C180000  cmpwi    dynamicBuffer,00000004C: 41820180  beq      *+384                   ; $000001CC00000050: 7F03C378  mr       r3,dynamicBuffer00000054: 48000001  bl       .HLock00000058: 60000000  nop0000005C: 80DF082C  lwz      r6,2092(theData)	;theData->width00000060: 80B80000  lwz      r5,0(dynamicBuffer)00000064: 1CC6000C  mulli    r6,r6,1200000068: 3B85000C  addi     eBuffer,r5,120000006C: 38C60018  addi     r6,r6,2400000070: 7F7C3214  add      oBuffer,eBuffer,r600000074: 4280000C  bc       ALWAYS,cr0_LT,*+12      ; $00000080	} else {		eBuffer = &evenDithering[1];		oBuffer = &oddDithering[1];	}00000078: 3B81526C  addi     eBuffer,SP,211000000007C: 3B61004C  addi     oBuffer,SP,76	if (theData->evodd & 1) 		ClearMem((Ptr)&eBuffer[-1], (theData->width + 2) * sizeof(DitherErrors));00000080: 80FF0834  lwz      r7,2100(theData)	;theData->evodd00000084: 70E70001  andi.    r7,r7,$000100000088: 41820020  beq      *+32                    ; $000000A80000008C: 811F082C  lwz      r8,2092(theData)	;theData->width00000090: 387CFFF4  subi     r3,eBuffer,1200000094: 39080002  addi     r8,r8,200000098: 1C88000C  mulli    r4,r8,120000009C: 48000001  bl       .ClearMem000000A0: 60000000  nop000000A4: 4280001C  bc       ALWAYS,cr0_LT,*+28      ; $000000C0	else ClearMem((Ptr)&oBuffer[-1], (theData->width + 2) * sizeof(DitherErrors));000000A8: 813F082C  lwz      r9,2092(theData)	;theData->width000000AC: 387BFFF4  subi     r3,oBuffer,12000000B0: 39290002  addi     r9,r9,2000000B4: 1C89000C  mulli    r4,r9,12000000B8: 48000001  bl       .ClearMem000000BC: 60000000  nop000000C0: 39400000  li       r10,0	rgnData.zero = 0;	rgnPtr = InitRegion(*theData->theRgn, &rgnData, &theData->boxRect);000000C4: 9141A484  stw      r10,-23420(SP)000000C8: 817F0838  lwz      r11,2104(theData)	;theData->theRgn000000CC: 3881A480  subi     r4,SP,23424000000D0: 806B0000  lwz      r3,0(r11)000000D4: 38BF083C  addi     r5,theData,2108	;theData->boxRect000000D8: 48000001  bl       .InitRegion000000DC: 7C7A1B78  mr       rgnPtr,r3	while (row--) {000000E0: 428000C4  bc       ALWAYS,cr0_LT,*+196     ; $000001A4		if ((++theData->evodd) & 1)			theData->odd((ulong *)src, dst, theData->itAddr, theData->ctAddr, eBuffer, 						oBuffer, rgnData.buffer, theData->errTable, theData->width);000000E4: 819F0834  lwz      r12,2100(theData)	;theData->evodd000000E8: 398C0001  addi     r12,r12,1000000EC: 919F0834  stw      r12,2100(theData)	;theData->evodd000000F0: 718C0001  andi.    r12,r12,$0001000000F4: 4182003C  beq      *+60                    ; $00000130000000F8: 807F082C  lwz      r3,2092(theData)	;theData->width000000FC: 7FA4EB78  mr       r4,dst00000100: 90610038  stw      r3,56(SP)00000104: 80BF0004  lwz      r5,4(theData)		;theData->itAddr00000108: 80DF0000  lwz      r6,0(theData)		;theData->ctAddr0000010C: 815F0018  lwz      r10,24(theData)	;theData->errTable00000110: 819F0014  lwz      r12,20(theData)	;theData->odd00000114: 7FC3F378  mr       r3,src00000118: 7F87E378  mr       r7,eBuffer0000011C: 7F68DB78  mr       r8,oBuffer00000120: 3921A488  subi     r9,SP,2341600000124: 48000001  bl       .__ptr_glue00000128: 60000000  nop0000012C: 42800038  bc       ALWAYS,cr0_LT,*+56      ; $00000164		else theData->even((ulong *)src, dst, theData->itAddr, theData->ctAddr, eBuffer, 						oBuffer, rgnData.buffer, theData->errTable, theData->width);00000130: 809F082C  lwz      r4,2092(theData)	;theData->width00000134: 7FC3F378  mr       r3,src00000138: 90810038  stw      r4,56(SP)0000013C: 80BF0004  lwz      r5,4(theData)		;theData->itAddr00000140: 80DF0000  lwz      r6,0(theData)		;theData->ctAddr00000144: 815F0018  lwz      r10,24(theData)	;theData->errTable00000148: 819F0010  lwz      r12,16(theData)	;theData->even0000014C: 7FA4EB78  mr       r4,dst00000150: 7F87E378  mr       r7,eBuffer00000154: 7F68DB78  mr       r8,oBuffer00000158: 3921A488  subi     r9,SP,234160000015C: 48000001  bl       .__ptr_glue00000160: 60000000  nop		if (!row) break;00000164: 2C190000  cmpwi    row,000000168: 4182004C  beq      *+76                    ; $000001B4		if (!--rgnData.yCount) rgnPtr = UpdateRegion(rgnPtr, &rgnData, &theData->boxRect);0000016C: 80A1A480  lwz      r5,-23424(SP)00000170: 38A5FFFF  subi     r5,r5,100000174: 2C050000  cmpwi    r5,000000178: 90A1A480  stw      r5,-23424(SP)0000017C: 40820018  bne      *+24                    ; $0000019400000180: 7F43D378  mr       r3,rgnPtr00000184: 3881A480  subi     r4,SP,2342400000188: 38BF083C  addi     r5,theData,2108	;theData->boxRect0000018C: 48000001  bl       .UpdateRegion00000190: 7C7A1B78  mr       rgnPtr,r3		src += theData->srcRow;		dst += theData->dstRow;00000194: 80DF001C  lwz      r6,28(theData)		;theData->srcRow00000198: 80FF0020  lwz      r7,32(theData)		;theData->dstRow0000019C: 7FDE3214  add      src,src,r6000001A0: 7FBD3A14  add      dst,dst,r7	}000001A4: 7F28CB78  mr       r8,row000001A8: 2C080000  cmpwi    r8,0000001AC: 3B39FFFF  subi     row,row,1000001B0: 4082FF34  bne      *-204                   ; $000000E4	if (theData->width > 1750) DisposeHandle(dynamicBuffer);000001B4: 813F082C  lwz      r9,2092(theData)	;theData->width000001B8: 2C0906D6  cmpwi    r9,1750000001BC: 40810010  ble      *+16                    ; $000001CC000001C0: 7F03C378  mr       r3,dynamicBuffer000001C4: 48000001  bl       .DisposeHandle000001C8: 60000000  nop000001CC: 8001A6B8  lwz      r0,-22856(SP)000001D0: 3821A6B0  subi     SP,SP,22864000001D4: 7C0803A6  mtlr     r0000001D8: BB01FFE0  lmw      r24,-32(SP)000001DC: 4E800020  blr*/