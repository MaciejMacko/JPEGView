/*********************************************************//* This source code copyright (c) 1991-2001, Aaron Giles *//* See the Read Me file for licensing information.       *//* Contact email: mac@aarongiles.com                     *//*********************************************************/#if THINK_C#include "THINK.Header"#elif applec#pragma load ":Headers:MPW.Header"#elif __MWERKS__//#include "MW.Header"#else#include "JPEGView.h"#endif/* * PixelMapAccessor(classWanted, container, containerClass, keyForm, keyData, *					resultToken, theRefCon) * *     Purpose: Finds a pixel map according to the specified keyForm and returns the *					corresponding pixel map token *      Inputs: classWanted = the element class desired (cPixelMap) *				container = token for this element's container *				containerClass = class of this element's container (cImage) *				keyForm = the search key type *				keyData = descriptor containing search key data *				resultToken = descriptor containing the resulting token *				theRefCon = reference constant *     Returns: an OSErr describing the result * */pascal OSErr PixelMapAccessor(DescType classWanted, AEDesc *container, 	DescType containerClass, DescType keyForm, AEDesc *keyData, 	AEDesc *resultToken, long theRefCon){#if applec#pragma unused(classWanted, containerClass, theRefCon)#endif	ObjectTokenHandle theList = (ObjectTokenHandle)container->dataHandle;	OSErr theErr = noErr;		if (IsValidForOne(keyForm, keyData)) {		if ((theErr = HandToHand((Handle *)&theList)) != noErr) return theErr;	} else return errAENoSuchObject;	if (!theList || !(*theList)->count || (theErr != noErr)) {		DisposeHandle((Handle)theList);		if (theErr == noErr) theErr = errAENoSuchObject;	} else {		theErr = AECreateHandleDesc(cPixelMap, (Handle)theList, resultToken);		DisposeHandle((Handle)theList);	}	return theErr;}/* * PixelPropertyAccessor(classWanted, container, containerClass, keyForm, keyData, *					    resultToken, theRefCon) * *     Purpose: Finds a pixel map property and returns the corresponding property token *      Inputs: classWanted = the element class desired (typeProperty) *				container = token for this element's container *				containerClass = class of this element's container (cFile) *				keyForm = the search key type *				keyData = descriptor containing search key data *				resultToken = descriptor containing the resulting token *				theRefCon = reference constant *     Returns: an OSErr describing the result * */pascal OSErr PixelPropertyAccessor(DescType classWanted, AEDesc *container, 	DescType containerClass, DescType keyForm, AEDesc *keyData, 	AEDesc *resultToken, long theRefCon){#if applec#pragma unused(classWanted, containerClass, theRefCon)#endif	ObjectTokenHandle theList = (ObjectTokenHandle)container->dataHandle;	DescType propertyType;	OSErr theErr;		if ((keyForm != formPropertyID) || (keyData->descriptorType != typeType))		return errAECantSupplyType;	propertyType = *(DescType *)*keyData->dataHandle;	switch (propertyType) {		// Non-modifiable properties		case pBestType:		case pBounds:		case pClass:		case pDefaultType:		case pPixelDepth:		case pTransferMode:			break;		default:			return errAEEventNotHandled;	}	theErr = HandToHand((Handle *)&theList);	if (theErr != noErr) return theErr;	(*theList)->property = propertyType;	(*theList)->objclass = cPixelMap;	theErr = AECreateHandleDesc(typeProperty, (Handle)theList, resultToken);	DisposeHandle((Handle)theList);	return theErr;}/* * GetPixelMapData(theWindow, typeWanted, theData) * *     Purpose: Extracts the data from the pixel map *      Inputs: theWindow = the window associated with this object *				typeWanted = the type we're asking for *				theData = the data we save *     Returns: an OSErr describing the result * */OSErr GetPixelMapData(WindowPtr theWindow, DescType typeWanted, AEDesc *theData){	if (typeWanted == typeWildCard) typeWanted = typeObjectSpecifier;	if (typeWanted == typeBest) typeWanted = typeObjectSpecifier;	if (typeWanted != typeObjectSpecifier) return errAECantSupplyType;	return MakePixelMapObject(theWindow, theData);}/* * GetPixelPropertyData(theWindow, theProperty, typeWanted, theData) * *     Purpose: Extracts the data from the pixel map's properties *      Inputs: theWindow = the window associated with this object *				theProperty = the property wanted *				typeWanted = the type we're asking for *				theData = the data we save *     Returns: an OSErr describing the result * */OSErr GetPixelPropertyData(WindowPtr theWindow, DescType theProperty, DescType typeWanted, 	AEDesc *theData){	ImageHandle theImage = FindImage(theWindow);	Boolean theBoolean = false;	DescType theType;	AEDesc bestData;	short theShort;	OSErr theErr;		if (!theImage) return errAEReadDenied;	switch (theProperty) {		case pBestType:		case pDefaultType:			theType = typeObjectSpecifier;			theErr = AECreateDesc(typeType, (void *)&theType, sizeof(DescType), &bestData);			break;		case pBounds:			theErr = AECreateDesc(typeQDRectangle, (void *)&(*theImage)->gworld->portRect, 					 sizeof(Rect), &bestData);			break;		case pClass:			theType = cPixelMap;			theErr = AECreateDesc(typeType, (void *)&theType, sizeof(DescType), &bestData);			break;		case pPixelDepth:			theShort = (*GetGWorldPixMap((*theImage)->gworld))->pixelSize;			theErr = AECreateDesc(typeShortInteger, (void *)&theShort, sizeof(short), &bestData);			break;		default:			return errAETypeError;	}	if (theErr != noErr) return theErr;	if ((bestData.descriptorType == typeWanted) ||		(typeWanted == typeWildCard) || (typeWanted == typeBest))		theErr = AEDuplicateDesc(&bestData, theData);	else theErr = AECoerceDesc(&bestData, typeWanted, theData);	AEDisposeDesc(&bestData);	return theErr;}/* * SetPixelPropertyData(theWindow, theProperty, theData) * *     Purpose: Sets the data for the pixel map's properties *      Inputs: theWindow = the associated window *				theProperty = the property wanted *				theData = the data to set it to *     Returns: an OSErr describing the result * */OSErr SetPixelPropertyData(WindowPtr theWindow, DescType theProperty, AEDesc *theData){#if applec#pragma unused(theData)#endif	ImageHandle theImage = FindImage(theWindow);	OSErr theErr;	if (!theImage) return errAEWriteDenied;	switch (theProperty) {		default:			theErr = errAEWriteDenied;			break;	}	return theErr;}/* * MakePixelMapObject(theWindow, theObject) * *     Purpose: Creates a pixel map object descriptor for the given window *      Inputs: theWindow = pointer to the window, or nil for all windows *				theObject = pointer to an AEDesc to store the result *     Returns: an OSErr describing what went wrong * */OSErr MakePixelMapObject(WindowPtr theWindow, AEDesc *theObject){	AEDesc theKey, theContainer;	long index = kAEFirst;	OSErr theErr = noErr;		theErr = MakeImageObject(theWindow, &theContainer);	if (theErr == noErr) {		theErr = AECreateDesc(typeAbsoluteOrdinal,(void *)&index, sizeof(long), &theKey);		if (theErr == noErr) {			theErr = CreateObjSpecifier(cPixelMap, &theContainer, formAbsolutePosition, 					 &theKey, false, theObject);			AEDisposeDesc(&theKey);		}		AEDisposeDesc(&theContainer);	}	return theErr;}/* * MakePixelPropertyObject(theWindow, theProperty, theObject) * *     Purpose: Creates a property object descriptor for the given images's property *      Inputs: theWindow = pointer to the window, or nil for all windows *				theObject = pointer to an AEDesc to store the result *     Returns: an OSErr describing what went wrong * */OSErr MakePixelPropertyObject(WindowPtr theWindow, DescType theProperty, AEDesc *theObject){	AEDesc theKey, theContainer;	OSErr theErr = noErr;		theErr = MakePixelMapObject(theWindow, &theContainer);	if (theErr == noErr) {		theErr = AECreateDesc(typeType, (void *)&theProperty, sizeof(DescType), &theKey);		if (theErr == noErr) {			theErr = CreateObjSpecifier(typeProperty, &theContainer, formPropertyID, 					 &theKey, false, theObject);			AEDisposeDesc(&theKey);		}		AEDisposeDesc(&theContainer);	}	return theErr;}