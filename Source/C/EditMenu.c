/*********************************************************//* This source code copyright (c) 1991-2001, Aaron Giles *//* See the Read Me file for licensing information.       *//* Contact email: mac@aarongiles.com                     *//*********************************************************/#if THINK_C#include "THINK.Header"#elif applec#pragma load ":Headers:MPW.Header"#elif __MWERKS__//#include "MW.Header"#else#include "JPEGView.h"#endif/* * HandleEditChoice(theItem) * *     Purpose: Accepts menu events from the Edit menu *      Inputs: theItem = the menu item number *     Returns: nothing * */ void HandleEditChoice(short theItem) {	ImageHandle theImage = FrontImage(), newImage;	Rect newRect, theRect;		switch (theItem) {		case editCutItem:			if (IsDialogWindow(FWFrontWindow())) DlgCut(FWFrontWindow());			break;		case editCopyItem:			if (IsDialogWindow(FWFrontWindow())) DlgCopy(FWFrontWindow());			else if (theImage) SendCopy();			break;		case editPasteItem:			if (IsDialogWindow(FWFrontWindow())) DlgPaste(FWFrontWindow());			break;		case editClearItem:			if (IsDialogWindow(FWFrontWindow())) DlgDelete(FWFrontWindow());			break;		case editSelectScreenItem:			DoSelectScreen(theImage);			break;		case editCropItem:			if (!theImage || !AntsHaveSelection((*theImage)->ants)) break;			SelRectToCropRect(theImage, &newRect);			if (SendCloneDocument(theImage, &newImage) == noErr) {				(*newImage)->flags &= ~(ifSelected + ifScreenSize + ifSelVisible);				(*newImage)->flags |= ifCropped;				if (SendSetImageBounds((*newImage)->window, &newRect) == noErr) {					if (!Full(newImage)) {						theRect = (*newImage)->wrect;						GlobalRect(&theRect, (*newImage)->window);						PositionWindow(&theRect, (*newImage)->dmon);						SendSetWindowBounds((*newImage)->window, &theRect);					}					SendMoveToFront((*newImage)->window);					SendSetWindowVis((*newImage)->window, true);				} else DoCloseWindow((*newImage)->window, gThePrefs.restoreColors);			}			break;		case editUncropItem:			if (!Cropped(theImage)) break;			theRect = (*theImage)->grect;/*			if ((*theImage)->format->inType == kPICTType && (*theImage)->compression &&				(Width(&theRect) < (*theImage)->desc.width || 				 Height(&theRect) < (*theImage)->desc.height))				MySetRect(&theRect, 0, 0, (*theImage)->desc.width, (*theImage)->desc.height);*/			SendSetImageBounds((*theImage)->window, &theRect);			(*theImage)->flags &= ~(ifSelected + ifScreenSize + ifCropped);			break;	}}/* * DoSelectScreen(theImage) * *     Purpose: Calculates the scaled size of the screen and selects the center of the *					active image at that size *      Inputs: none *     Returns: nothing * */ void DoSelectScreen(ImageHandle theImage){	Rect srect, crect, trect;	Boolean itDoesntFit;		if (!theImage) return;	crect = (*theImage)->crect;	GetActiveRect((*theImage)->dmon, &srect);	if (!Full(theImage)) srect.top += gTitleBarHeight;	OffsetRect(&srect, -srect.left, -srect.top);	if (srect.right >= Width(&crect)) srect.right = Width(&crect);	if (srect.bottom >= Height(&crect)) srect.bottom = Height(&crect);	do {		itDoesntFit = false;		trect = srect;		MapRect(&trect, &crect, &(*theImage)->wrect);		MapRect(&trect, &(*theImage)->wrect, &crect);		if (Width(&trect) > Width(&srect)) {			srect.right--;			itDoesntFit = true;		}		if (Height(&trect) > Height(&srect)) {			srect.bottom--;			itDoesntFit = true;		}	} while (itDoesntFit);	OffsetRect(&srect, crect.left + ((Width(&crect) - srect.right) >> 1),					   crect.top + ((Height(&crect) - srect.bottom) >> 1));	MapRect(&srect, &crect, &(*theImage)->wrect);	(*theImage)->flags |= ifScreenSize;	SendSetSelection(theImage, &srect);}extern void SelRectToCropRect(ImageHandle theImage, Rect *newRect){	GetAntsSelection((*theImage)->ants, newRect);	MapRect(newRect, &(*theImage)->wrect, &(*theImage)->crect);	if (ScreenSize(theImage)) ForceScreenSize(theImage, newRect);}