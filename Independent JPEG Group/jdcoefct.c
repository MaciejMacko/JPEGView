/* * jdcoefct.c * * Copyright (C) 1994, Thomas G. Lane. * This file is part of the Independent JPEG Group's software. * For conditions of distribution and use, see the accompanying README file. * * This file contains the coefficient buffer controller for decompression. * This controller is the top level of the JPEG decompressor proper. * The coefficient buffer lies between entropy decoding and inverse-DCT steps. * * For now, this file does not support a full-image coefficient buffer. * One will be necessary to handle noninterleaved or progressive JPEG files. */#define JPEG_INTERNALS#include "jinclude.h"#include "jpeglib.h"/* Private buffer controller object */typedef struct {  struct jpeg_d_coef_controller pub; /* public fields */  JDIMENSION MCU_col_num;	/* saves next MCU column to process */  JDIMENSION MCU_row_num;	/* keep track of MCU row # within image */  /* When not doing block smoothing, it's sufficient to buffer just one MCU   * (although this may prove a bit slow in practice).  We allocate a   * workspace of MAX_BLOCKS_IN_MCU coefficient blocks, and let the entropy   * decoder write into that workspace each time.  On 80x86, the workspace   * is FAR even though it's not really very big; this is to keep the   * module interfaces unchanged when a large coefficient buffer is necessary.   */  JBLOCKROW MCU_buffer[MAX_BLOCKS_IN_MCU];} my_coef_controller;typedef my_coef_controller * my_coef_ptr;/* * Initialize for a processing pass. */METHODDEF voidstart_pass (j_decompress_ptr cinfo, J_BUF_MODE pass_mode){  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;  switch (pass_mode) {  case JBUF_PASS_THRU:    break;  default:    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);    break;  }  coef->MCU_col_num = 0;  coef->MCU_row_num = 0;}/* * Process some data. * Always attempts to emit one fully interleaved MCU row ("iMCU" row). * Returns TRUE if it completed a row, FALSE if not (suspension). * * NB: output_buf contains a plane for each component in image. * For now, we assume this is the same as the components in the scan. */METHODDEF booleandecompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf){  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;  JDIMENSION MCU_col_num;	/* index of current MCU within row */  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;  JDIMENSION last_MCU_row = cinfo->MCU_rows_in_scan - 1;  int blkn, ci, xindex, yindex, useful_width;  JSAMPARRAY output_ptr;  JDIMENSION start_col, output_col;  jpeg_component_info *compptr;  inverse_DCT_method_ptr inverse_DCT;  /* Loop to process as much as one whole MCU row */  for (MCU_col_num = coef->MCU_col_num; MCU_col_num <= last_MCU_col;       MCU_col_num++) {    /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */    jzero_far((void FAR *) coef->MCU_buffer[0],	      (size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));    if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {      /* Suspension forced; return with row unfinished */      coef->MCU_col_num = MCU_col_num; /* update my state */      return FALSE;    }    /* Determine where data should go in output_buf and do the IDCT thing.     * We skip dummy blocks at the right and bottom edges (but blkn gets     * incremented past them!).  Note the inner loop relies on having     * allocated the MCU_buffer[] blocks sequentially.     */    blkn = 0;			/* index of current DCT block within MCU */    for (ci = 0; ci < cinfo->comps_in_scan; ci++) {      compptr = cinfo->cur_comp_info[ci];      /* Don't bother to IDCT an uninteresting component. */      if (! compptr->component_needed) {	blkn += compptr->MCU_blocks;	continue;      }      inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];      if (MCU_col_num < last_MCU_col)	useful_width = compptr->MCU_width;      else	useful_width = compptr->last_col_width;      output_ptr = output_buf[ci];      start_col = MCU_col_num * compptr->MCU_sample_width;      for (yindex = 0; yindex < compptr->MCU_height; yindex++) {	if (coef->MCU_row_num < last_MCU_row ||	    yindex < compptr->last_row_height) {	  output_col = start_col;	  for (xindex = 0; xindex < useful_width; xindex++) {	    (*inverse_DCT) (cinfo, (JCOEFPTR) coef->MCU_buffer[blkn+xindex],			    output_ptr, output_col);	    output_col += compptr->DCT_scaled_size;	  }	}	blkn += compptr->MCU_width;	output_ptr += compptr->DCT_scaled_size;      }    }  }  /* We finished the row successfully */  coef->MCU_col_num = 0;	/* prepare for next row */  coef->MCU_row_num++;  return TRUE;}/* * Initialize coefficient buffer controller. */GLOBAL voidjinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer){  my_coef_ptr coef;  JBLOCKROW buffer;  int i;  coef = (my_coef_ptr)    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,				SIZEOF(my_coef_controller));  cinfo->coef = (struct jpeg_d_coef_controller *) coef;  coef->pub.start_pass = start_pass;  coef->pub.decompress_data = decompress_data;  /* Create the coefficient buffer. */  if (need_full_buffer) {    ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);  } else {    buffer = (JBLOCKROW)      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,				  MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));    for (i = 0; i < MAX_BLOCKS_IN_MCU; i++) {      coef->MCU_buffer[i] = buffer + i;    }  }}